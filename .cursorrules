# Cursor AI Rules for ProfitBuild Dashboard

## Supabase Database Migrations - CRITICAL

### When Using Supabase MCP in Cursor

**ALWAYS follow this workflow when applying database migrations:**

1. **After applying ANY migration via `mcp_supabase_apply_migration`:**
   - IMMEDIATELY query the database to get the exact migration name that was recorded:
     ```sql
     SELECT version, name FROM supabase_migrations.schema_migrations 
     ORDER BY version DESC LIMIT 1;
     ```
   
2. **Create a matching local placeholder file:**
   - Filename format: `{version}_{name}.sql` or `{version}_migration.sql` if name is empty
   - Location: `supabase/migrations/`
   - Content: `-- Applied via Supabase dashboard since the actual SQL is already in your database.`
   - Example: `supabase/migrations/20260108191339_add_last_active_at_to_profiles.sql`

3. **Verify synchronization:**
   - Compare local file count with database migration count
   - Local files MUST match database exactly for CI/CD to pass

### Why This Matters

- Supabase CI/CD validates that every database migration has a corresponding local file
- Database records migrations with UTC timestamps
- Filenames MUST match exactly: `{version}_{name}.sql`
- Missing or mismatched files cause deployment failures

### Example Workflow

```typescript
// 1. Apply migration
await mcp_supabase_apply_migration({
  project_id: "...",
  name: "add_new_feature",
  query: "ALTER TABLE..."
});

// 2. Query to get exact name
const result = await mcp_supabase_execute_sql({
  query: "SELECT version, name FROM supabase_migrations.schema_migrations ORDER BY version DESC LIMIT 1"
});

// 3. Create local file
const filename = `${result.version}_${result.name || 'migration'}.sql`;
await write({
  file_path: `supabase/migrations/${filename}`,
  contents: "-- Applied via Supabase dashboard since the actual SQL is already in your database.\n"
});
```

## Troubleshooting Deployment Failures

### "Failed to bundle function" Error

This error is **misleading** - it often means migration validation failed, NOT an edge function syntax error.

**Diagnosis workflow:**

1. **Check migration alignment first:**
   ```sql
   SELECT COUNT(*) FROM supabase_migrations.schema_migrations;
   ```
   Compare to: `(Get-ChildItem supabase\migrations\*.sql).Count`

2. **If counts don't match - sync missing migrations:**
   ```sql
   SELECT version, name FROM supabase_migrations.schema_migrations 
   WHERE version > '20260101000000' 
   ORDER BY version;
   ```
   Create placeholder files for any missing migrations

3. **Then check edge function syntax:**
   - Use `ReadLints` on edge function files
   - Look for duplicate variable declarations
   - Check for incomplete template literals
   - Verify all imports are valid

### Periodic Health Check

Run this check weekly or after using Lovable:

```typescript
// 1. Get DB migration count
const dbCount = await mcp_supabase_execute_sql({
  query: "SELECT COUNT(*) FROM supabase_migrations.schema_migrations"
});

// 2. Count local files
const localCount = (await glob("supabase/migrations/*.sql")).length;

// 3. If mismatch, query missing migrations and create placeholders
if (dbCount !== localCount) {
  // Query DB for all migrations
  // Compare to local files
  // Create missing placeholder files
}
```

## Database Best Practices

1. **Always use `mcp_supabase_apply_migration` for DDL operations** (CREATE, ALTER, DROP)
2. **Use `mcp_supabase_execute_sql` only for queries and DML** (SELECT, INSERT, UPDATE, DELETE)
3. **Never hardcode UUIDs in migrations** - they won't match between environments
4. **Test migrations on a branch first** before applying to production
5. **After working in Lovable** - always verify migration alignment before deploying

## Edge Functions Best Practices

### Common Pitfalls to Avoid

1. **Duplicate variable declarations** - Check for accidental copy-paste duplicates
2. **Incomplete template literals** - Ensure all backtick strings are properly closed
3. **Variable scope in try-catch** - Declare variables outside try block if used in catch
4. **Missing Deno imports** - Always import from official Deno/ESM sources

### Pre-deployment Checklist

Before committing edge function changes:
- Run `ReadLints` on the edge function file
- Check for duplicate `const/let/var` declarations
- Verify all template literals are complete
- Test locally if possible with `supabase functions serve`

## Code Style

- Use TypeScript for all new files
- Follow existing project patterns
- Use Shadcn UI components consistently
- Maintain proper error handling with try-catch blocks

## Git Workflow

- Never force push to main/master
- Always pull before pushing
- Write descriptive commit messages
- Reference issue numbers when applicable

## Security

- Never commit API keys, tokens, or credentials
- Use environment variables for sensitive data
- Follow RLS (Row Level Security) patterns in Supabase
- Validate user input on both client and server
