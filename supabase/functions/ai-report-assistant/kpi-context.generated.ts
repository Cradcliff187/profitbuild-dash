/**
 * AUTO-GENERATED KPI CONTEXT FOR EDGE FUNCTION
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 *
 * Generated by: scripts/sync-edge-kpi-context.ts
 * Generated at: 2026-01-28T01:20:50.536Z
 * Source version: 3.0.0
 * Source last updated: 2026-01-28
 *
 * To regenerate, run: npx tsx scripts/sync-edge-kpi-context.ts
 *
 * KPI Counts:
 * - Project: 32
 * - Estimate: 23
 * - Expense: 17
 * - Quote: 12
 * - Revenue: 15
 * - Change Order: 15
 * - Work Order: 22
 * - Deprecated: 7
 * - TOTAL: 143
 */

export const KPI_CONTEXT = {
  version: '3.0.0',
  generatedAt: '2026-01-28T01:20:50.536Z',
  sourceLastUpdated: '2026-01-28',

  // Semantic lookup: business term -> database field
  semanticLookup: {
  "profit": "projects.actual_margin",
  "earnings": "projects.actual_margin",
  "made": "projects.actual_margin",
  "earned": "projects.actual_margin",
  "net": "projects.actual_margin",
  "bottom line": "projects.actual_margin",
  "margin": "projects.current_margin",
  "markup": "projects.current_margin",
  "spread": "projects.current_margin",
  "revenue": "reporting.project_financials.total_invoiced",
  "income": "reporting.project_financials.total_invoiced",
  "sales": "reporting.project_financials.total_invoiced",
  "money coming in": "reporting.project_financials.total_invoiced",
  "billed": "reporting.project_financials.total_invoiced",
  "contract": "projects.contracted_amount",
  "contract value": "projects.contracted_amount",
  "deal size": "projects.contracted_amount",
  "project value": "projects.contracted_amount",
  "invoiced": "reporting.project_financials.total_invoiced",
  "collected": "reporting.project_financials.total_invoiced",
  "received": "reporting.project_financials.total_invoiced",
  "remaining to bill": "reporting.project_financials.revenue_variance",
  "unbilled": "reporting.project_financials.revenue_variance",
  "left to invoice": "reporting.project_financials.revenue_variance",
  "billing gap": "reporting.project_financials.revenue_variance",
  "still owed": "reporting.project_financials.revenue_variance",
  "costs": "reporting.project_financials.total_expenses",
  "expenses": "reporting.project_financials.total_expenses",
  "spent": "reporting.project_financials.total_expenses",
  "spending": "reporting.project_financials.total_expenses",
  "outflow": "reporting.project_financials.total_expenses",
  "paid out": "reporting.project_financials.total_expenses",
  "budget": "projects.adjusted_est_costs",
  "budgeted": "projects.adjusted_est_costs",
  "estimated costs": "projects.adjusted_est_costs",
  "planned costs": "projects.adjusted_est_costs",
  "over budget": "reporting.project_financials.cost_variance",
  "overspent": "reporting.project_financials.cost_variance",
  "exceeded budget": "reporting.project_financials.cost_variance",
  "cost overrun": "reporting.project_financials.cost_variance",
  "under budget": "reporting.project_financials.cost_variance",
  "savings": "reporting.project_financials.cost_variance",
  "cost savings": "reporting.project_financials.cost_variance",
  "below budget": "reporting.project_financials.cost_variance",
  "contingency": "projects.contingency_remaining",
  "buffer": "projects.contingency_remaining",
  "reserve": "projects.contingency_remaining",
  "safety margin": "projects.contingency_remaining",
  "labor": "reporting.project_financials.estimated_labor_hours",
  "workers": "reporting.project_financials.estimated_labor_hours",
  "hours": "expenses.hours",
  "time": "reporting.project_financials.estimated_labor_hours",
  "labor costs": "reporting.project_financials.estimated_labor_hours",
  "labor cushion": "reporting.project_financials.estimated_labor_cushion",
  "labor opportunity": "reporting.project_financials.estimated_labor_cushion",
  "labor profit": "reporting.project_financials.estimated_labor_cushion",
  "hidden profit": "reporting.project_financials.estimated_labor_cushion",
  "rate spread": "reporting.project_financials.estimated_labor_cushion",
  "time worked": "expenses.hours",
  "hours logged": "expenses.hours",
  "time entries": "expenses.hours",
  "hours worked": "expenses.hours",
  "estimated hours": "reporting.project_financials.estimated_labor_hours",
  "planned hours": "reporting.project_financials.estimated_labor_hours",
  "budgeted hours": "reporting.project_financials.estimated_labor_hours",
  "labor estimate": "reporting.project_financials.estimated_labor_hours",
  "employee": "",
  "worker": "",
  "staff": "",
  "team member": "",
  "internal": "",
  "subcontractor": "",
  "sub": "",
  "trade contractor": "",
  "contractor": "",
  "vendor": "",
  "supplier": "",
  "material supplier": "",
  "quotes": "projects.total_accepted_quotes",
  "bids": "projects.total_accepted_quotes",
  "proposals": "projects.total_accepted_quotes",
  "vendor quotes": "projects.total_accepted_quotes",
  "change orders": "change_orders.amount",
  "cos": "change_orders.amount",
  "changes": "change_orders.amount",
  "scope changes": "change_orders.amount",
  "modifications": "change_orders.amount",
  "active projects": "projects.status",
  "in progress": "projects.status",
  "ongoing": "projects.status",
  "current projects": "projects.status",
  "completed projects": "projects.status",
  "finished": "projects.status",
  "done": "projects.status",
  "closed": "projects.status",
  "performance": "projects.margin_percentage",
  "doing": "projects.margin_percentage",
  "performing": "projects.margin_percentage",
  "health": "projects.margin_percentage",
  "at risk": "reporting.project_financials.cost_variance",
  "troubled": "reporting.project_financials.cost_variance",
  "problem": "reporting.project_financials.cost_variance",
  "warning": "reporting.project_financials.cost_variance",
  "concern": "reporting.project_financials.cost_variance"
},

  // KPI definitions with aliases and formulas
  kpiDefinitions: {
  "contracted_amount": {
    "field": "projects.contracted_amount",
    "aliases": [
      "contract value",
      "contract amount",
      "total contract",
      "revenue"
    ],
    "formula": "Base estimate amount + approved change order client amounts",
    "notes": "Total contract value with client. Updated by triggers when estimates approved or change orders accepted."
  },
  "total_invoiced": {
    "field": "reporting.project_financials.total_invoiced",
    "aliases": [
      "invoiced",
      "billed",
      "actual revenue",
      "received"
    ],
    "formula": "SUM(project_revenues.amount) for direct + SUM(revenue_splits.split_amount) for splits",
    "notes": "Actual revenue received. Handles split invoices correctly via the view."
  },
  "invoice_count": {
    "field": "reporting.project_financials.invoice_count",
    "aliases": [],
    "formula": "COUNT(project_revenues) + COUNT(revenue_splits)",
    "notes": "Total number of invoices/revenue entries for the project."
  },
  "revenue_variance": {
    "field": "reporting.project_financials.revenue_variance",
    "aliases": [
      "billing gap",
      "remaining to bill",
      "unbilled"
    ],
    "formula": "contracted_amount - total_invoiced",
    "notes": "How much is left to bill. Positive = still owed, Negative = overbilled."
  },
  "current_margin": {
    "field": "projects.current_margin",
    "aliases": [
      "margin",
      "expected margin"
    ],
    "formula": "contracted_amount - total_expenses",
    "notes": "UNREALIZED margin based on contract value minus expenses. Does NOT reflect actual invoiced revenue."
  },
  "actual_margin": {
    "field": "projects.actual_margin",
    "aliases": [
      "real margin",
      "real profit",
      "actual profit",
      "profit",
      "true margin"
    ],
    "formula": "total_invoiced - total_expenses",
    "notes": "REAL profit based on actual invoices received minus actual expenses. This is true profit."
  },
  "projected_margin": {
    "field": "projects.projected_margin",
    "aliases": [
      "expected margin",
      "forecast margin"
    ],
    "formula": "contracted_amount - adjusted_est_costs",
    "notes": "Expected final margin based on current estimates (adjusted for accepted quotes)."
  },
  "original_margin": {
    "field": "projects.original_margin",
    "aliases": [
      "baseline margin",
      "initial margin"
    ],
    "formula": "contracted_amount - original_est_costs",
    "notes": "Margin from original approved estimate. Immutable baseline for comparison."
  },
  "margin_percentage": {
    "field": "projects.margin_percentage",
    "aliases": [
      "margin %",
      "margin percent",
      "profit margin"
    ],
    "formula": "(current_margin / contracted_amount) × 100",
    "notes": "Current margin as percentage of contract value."
  },
  "total_expenses": {
    "field": "reporting.project_financials.total_expenses",
    "aliases": [
      "costs",
      "actual costs",
      "expenses",
      "spent"
    ],
    "formula": "SUM(expenses.amount) for direct + SUM(expense_splits.split_amount) for splits",
    "notes": "All actual costs incurred. Handles split expenses correctly via the view."
  },
  "original_est_costs": {
    "field": "projects.original_est_costs",
    "aliases": [
      "original costs",
      "baseline costs",
      "initial estimate"
    ],
    "formula": "Total cost from original approved estimate",
    "notes": "Immutable baseline cost estimate. Set when estimate first approved."
  },
  "adjusted_est_costs": {
    "field": "projects.adjusted_est_costs",
    "aliases": [
      "current estimate",
      "revised costs",
      "budget"
    ],
    "formula": "original_est_costs + accepted_quote_costs + change_order_costs",
    "notes": "Current expected costs including all approved changes."
  },
  "cost_variance": {
    "field": "reporting.project_financials.cost_variance",
    "aliases": [
      "budget variance",
      "over/under budget"
    ],
    "formula": "total_expenses - adjusted_est_costs",
    "notes": "Positive = over budget, Negative = under budget."
  },
  "cost_variance_percent": {
    "field": "reporting.project_financials.cost_variance_percent",
    "aliases": [],
    "formula": "(cost_variance / adjusted_est_costs) × 100",
    "notes": "Cost variance as percentage of budget."
  },
  "budget_utilization_percent": {
    "field": "reporting.project_financials.budget_utilization_percent",
    "aliases": [
      "budget used",
      "spend rate"
    ],
    "formula": "(total_expenses / adjusted_est_costs) × 100",
    "notes": "Percentage of estimated budget consumed. Uses adjusted_est_costs (budget) as denominator, not contracted_amount (revenue)."
  },
  "remaining_budget": {
    "field": "reporting.project_financials.remaining_budget",
    "aliases": [
      "budget remaining",
      "available budget"
    ],
    "formula": "adjusted_est_costs - total_expenses",
    "notes": "How much of the estimated budget is left to spend. Different from current_margin which uses contracted_amount (revenue)."
  },
  "contingency_amount": {
    "field": "projects.contingency_amount",
    "aliases": [
      "contingency",
      "buffer",
      "reserve"
    ],
    "formula": "User-defined buffer for unknowns (typically % of estimate)",
    "notes": "Total contingency allocated to project."
  },
  "contingency_used": {
    "field": "projects.contingency_used",
    "aliases": [],
    "formula": "SUM(expenses marked as contingency) + change orders using contingency",
    "notes": "How much contingency has been consumed."
  },
  "contingency_remaining": {
    "field": "projects.contingency_remaining",
    "aliases": [
      "available contingency"
    ],
    "formula": "contingency_amount - contingency_used",
    "notes": "Available contingency buffer."
  },
  "contingency_percent": {
    "field": "projects.contingency_percent",
    "aliases": [],
    "formula": "(contingency_amount / contracted_amount) × 100"
  },
  "target_margin": {
    "field": "projects.target_margin",
    "aliases": [],
    "formula": "User-defined goal amount",
    "notes": "Desired margin goal for the project."
  },
  "target_margin_percent": {
    "field": "projects.target_margin_percent",
    "aliases": [],
    "formula": "(target_margin / contracted_amount) × 100"
  },
  "minimum_margin": {
    "field": "projects.minimum_margin",
    "aliases": [],
    "formula": "User-defined floor amount (alert threshold)",
    "notes": "Below this triggers warnings."
  },
  "minimum_margin_percent": {
    "field": "projects.minimum_margin_percent",
    "aliases": [],
    "formula": "(minimum_margin / contracted_amount) × 100"
  },
  "total_accepted_quotes": {
    "field": "projects.total_accepted_quotes",
    "aliases": [
      "accepted quotes",
      "vendor quotes total"
    ],
    "formula": "SUM(quotes.quote_amount WHERE status = accepted)",
    "notes": "Sum of all accepted vendor quotes."
  },
  "estimated_labor_cushion": {
    "field": "reporting.project_financials.estimated_labor_cushion",
    "aliases": [
      "labor opportunity",
      "labor profit",
      "cushion"
    ],
    "formula": "SUM(labor_cushion_amount) from approved estimates",
    "notes": "Hidden profit opportunity from billing labor at $75/hr vs $35/hr actual cost."
  },
  "estimated_max_profit_potential": {
    "field": "reporting.project_financials.estimated_max_profit_potential",
    "aliases": [
      "max profit",
      "profit potential"
    ],
    "formula": "SUM(max_gross_profit_potential) from approved estimates",
    "notes": "Maximum achievable profit if all labor cushion is captured."
  },
  "estimated_labor_hours": {
    "field": "reporting.project_financials.estimated_labor_hours",
    "aliases": [
      "labor hours",
      "estimated hours"
    ],
    "formula": "SUM(labor_hours) from approved estimates",
    "notes": "Total internal labor hours across approved estimates."
  },
  "project_status": {
    "field": "projects.status",
    "aliases": [
      "status"
    ],
    "formula": "ENUM: 'estimating' | 'quoted' | 'approved' | 'in_progress' | 'complete' | 'on_hold' | 'cancelled'"
  },
  "project_type": {
    "field": "projects.project_type",
    "aliases": [],
    "formula": "ENUM: 'construction_project' | 'work_order'",
    "notes": "Distinguishes full projects from work orders."
  },
  "project_category": {
    "field": "projects.category",
    "aliases": [
      "category"
    ],
    "formula": "ENUM: 'construction' | 'system' | 'overhead'",
    "notes": "CRITICAL: Filter by category=construction for most reports. System/overhead are internal."
  },
  "do_not_exceed": {
    "field": "projects.do_not_exceed",
    "aliases": [
      "DNE",
      "budget cap",
      "max budget"
    ],
    "formula": "Maximum billable amount (work orders)",
    "notes": "Budget cap for work orders."
  },
  "estimate_total_amount": {
    "field": "estimates.total_amount",
    "aliases": [
      "estimate amount",
      "total estimate",
      "estimate value"
    ],
    "formula": "SUM(estimate_line_items.total) for approved estimate",
    "notes": "Total estimated amount including markup for client presentation."
  },
  "estimate_total_cost": {
    "field": "estimates.total_cost",
    "aliases": [
      "estimate cost",
      "total cost",
      "estimated cost"
    ],
    "formula": "SUM(estimate_line_items.total_cost) for approved estimate",
    "notes": "For labor items, uses billing rate (not actual cost) to hide cushion. For materials, uses actual vendor cost."
  },
  "estimate_contingency_amount": {
    "field": "estimates.contingency_amount",
    "aliases": [
      "contingency",
      "buffer amount",
      "estimate contingency"
    ],
    "formula": "User-defined or calculated buffer amount",
    "notes": "Additional buffer for unknowns, typically 5-15% of total."
  },
  "estimate_contingency_percent": {
    "field": "estimates.contingency_percent",
    "aliases": [
      "contingency %",
      "buffer percent"
    ],
    "formula": "(contingency_amount / total_amount) × 100"
  },
  "estimate_default_markup_percent": {
    "field": "estimates.default_markup_percent",
    "aliases": [
      "default markup",
      "standard markup"
    ],
    "formula": "User-defined default for line items (typically 10-30%)",
    "notes": "Default markup applied to line items when created."
  },
  "estimate_target_margin_percent": {
    "field": "estimates.target_margin_percent",
    "aliases": [
      "target margin",
      "profit target"
    ],
    "formula": "User-defined profitability goal (typically 15-25%)"
  },
  "estimate_is_auto_generated": {
    "field": "estimates.is_auto_generated",
    "aliases": [
      "auto generated",
      "quick estimate"
    ],
    "formula": "Boolean flag - true when created from Quick Work Order",
    "notes": "Indicates placeholder estimate created automatically."
  },
  "estimate_line_item_total": {
    "field": "estimate_line_items.total",
    "aliases": [
      "line total",
      "item total"
    ],
    "formula": "quantity × price_per_unit",
    "notes": "Total amount for this line item including markup."
  },
  "estimate_line_item_total_cost": {
    "field": "estimate_line_items.total_cost",
    "aliases": [
      "line cost",
      "item cost",
      "actual cost"
    ],
    "formula": "quantity × cost_per_unit"
  },
  "estimate_line_item_markup_amount": {
    "field": "estimate_line_items.markup_amount",
    "aliases": [
      "markup amount",
      "profit amount"
    ],
    "formula": "total - total_cost"
  },
  "estimate_line_item_markup_percent": {
    "field": "estimate_line_items.markup_percent",
    "aliases": [
      "markup %",
      "profit margin %"
    ],
    "formula": "(markup_amount / total_cost) × 100"
  },
  "estimate_labor_hours": {
    "field": "estimate_line_items.labor_hours",
    "aliases": [
      "labor hours",
      "hours",
      "estimated hours"
    ],
    "formula": "Hours for labor_internal line items only",
    "notes": "Only populated for labor_internal category. Used for time tracking and resource planning."
  },
  "estimate_billing_rate_per_hour": {
    "field": "estimate_line_items.billing_rate_per_hour",
    "aliases": [
      "billing rate",
      "hourly rate",
      "client rate"
    ],
    "formula": "Rate shown to client (e.g., $75/hr)",
    "notes": "What the client is charged per hour. Used as cost_per_unit to hide actual labor cost."
  },
  "estimate_actual_cost_rate_per_hour": {
    "field": "estimate_line_items.actual_cost_rate_per_hour",
    "aliases": [
      "actual rate",
      "internal rate",
      "true cost rate"
    ],
    "formula": "True internal cost (e.g., $35/hr)",
    "notes": "Hidden from client. Represents true cost to RCG for labor."
  },
  "estimate_labor_cushion_amount": {
    "field": "estimate_line_items.labor_cushion_amount",
    "aliases": [
      "labor cushion",
      "labor profit",
      "hidden profit",
      "cushion amount"
    ],
    "formula": "(billing_rate - actual_cost_rate) × labor_hours",
    "notes": "Hidden profit opportunity built into labor billing. (billing_rate - actual_cost_rate) × hours."
  },
  "estimate_total_labor_cushion": {
    "field": "calculateTotalLaborCushionAmount()",
    "aliases": [
      "total cushion",
      "labor opportunity",
      "hidden profit total"
    ],
    "formula": "SUM(labor_cushion_amount) for all labor items",
    "notes": "Total hidden profit opportunity from all labor line items."
  },
  "estimate_max_gross_profit_potential": {
    "field": "trueProfitMargin",
    "aliases": [
      "max profit",
      "true profit",
      "profit potential"
    ],
    "formula": "Gross Profit + Total Labor Cushion",
    "notes": "Maximum achievable profit if all labor cushion is captured."
  },
  "estimate_max_potential_margin_percent": {
    "field": "trueProfitPercent",
    "aliases": [
      "true margin",
      "actual margin %",
      "real margin percent"
    ],
    "formula": "(Max Gross Profit / (Total Cost - Labor Cushion)) × 100",
    "notes": "True margin based on actual costs, not billing costs. Shows what margin really is."
  },
  "estimate_true_actual_cost": {
    "field": "trueActualCost",
    "aliases": [
      "true cost",
      "actual internal cost",
      "real cost"
    ],
    "formula": "Total Cost - Total Labor Cushion",
    "notes": "What the project actually costs internally (billing costs minus cushion)."
  },
  "estimate_gross_profit": {
    "field": "calculateEstimateGrossProfit()",
    "aliases": [
      "profit",
      "markup profit",
      "gross margin amount"
    ],
    "formula": "Total Amount - Total Cost",
    "notes": "Standard visible markup profit only (excludes labor cushion)."
  },
  "estimate_gross_margin": {
    "field": "calculateEstimateGrossMargin()",
    "aliases": [
      "margin %",
      "profit margin",
      "markup percent"
    ],
    "formula": "(Gross Profit / Total Amount) × 100",
    "notes": "Margin shown to clients (excludes labor cushion)."
  },
  "estimate_average_markup": {
    "field": "calculateEstimateAverageMarkup()",
    "aliases": [
      "avg markup",
      "average profit margin"
    ],
    "formula": "AVG(line_items.markup_percent)"
  },
  "estimate_total_markup": {
    "field": "calculateEstimateTotalMarkup()",
    "aliases": [
      "total markup amount",
      "total profit amount"
    ],
    "formula": "SUM(line_items.markup_amount)"
  },
  "expense_amount": {
    "field": "expenses.amount",
    "aliases": [
      "amount",
      "cost",
      "expense cost",
      "transaction amount"
    ],
    "formula": "Direct field - transaction amount",
    "notes": "The actual dollar amount of the expense transaction."
  },
  "expense_is_split": {
    "field": "expenses.is_split",
    "aliases": [
      "split expense",
      "allocated expense"
    ],
    "formula": "Boolean - expense allocated across multiple projects",
    "notes": "When true, expense is split across multiple projects via expense_splits table."
  },
  "expense_split_amount": {
    "field": "expense_splits.split_amount",
    "aliases": [
      "allocated amount",
      "portion amount"
    ],
    "formula": "Portion allocated to specific project",
    "notes": "How much of the parent expense is allocated to this specific project."
  },
  "expense_split_percentage": {
    "field": "expense_splits.split_percentage",
    "aliases": [
      "allocation percent",
      "split %"
    ],
    "formula": "(split_amount / parent_expense.amount) × 100"
  },
  "expense_lunch_taken": {
    "field": "expenses.lunch_taken",
    "aliases": [
      "took lunch",
      "lunch break",
      "had lunch"
    ],
    "formula": "Boolean - whether lunch break was taken during shift",
    "notes": "Only applicable to labor_internal expenses (time entries)."
  },
  "expense_lunch_duration_minutes": {
    "field": "expenses.lunch_duration_minutes",
    "aliases": [
      "lunch minutes",
      "lunch duration",
      "break time"
    ],
    "formula": "Integer (15-120) - duration of lunch break in minutes",
    "notes": "Only meaningful when lunch_taken = true. Typically 30-60 minutes."
  },
  "expense_gross_hours": {
    "field": "expenses.gross_hours",
    "aliases": [
      "gross hours",
      "total hours",
      "shift hours",
      "raw hours"
    ],
    "formula": "(end_time - start_time) / 3600",
    "notes": "Total shift duration before lunch deduction. Calculated from timestamp fields."
  },
  "expense_net_hours": {
    "field": "expenses.hours",
    "aliases": [
      "hours",
      "billable hours",
      "net hours",
      "productive hours",
      "worked hours"
    ],
    "formula": "Gross Hours - (Lunch Duration / 60) when lunch_taken = true",
    "notes": "Billable hours after lunch deduction. Stored in expenses.hours field. Amount = Net Hours × Hourly Rate."
  },
  "total_expenses_by_project": {
    "field": "calculateProjectExpenses()",
    "aliases": [
      "project expenses",
      "total project costs",
      "project spend"
    ],
    "formula": "SUM(expenses.amount) + SUM(expense_splits.split_amount)",
    "notes": "Combines direct expenses and split expense allocations for accurate project totals."
  },
  "expense_count_by_project": {
    "field": "calculateExpenseCount()",
    "aliases": [
      "expense count",
      "number of expenses"
    ],
    "formula": "COUNT(expenses) + COUNT(expense_splits)",
    "notes": "Total number of expense records for the project, including splits."
  },
  "expense_start_time": {
    "field": "expenses.start_time",
    "aliases": [
      "clock in",
      "start",
      "begin time"
    ],
    "formula": "Timestamp when time entry began",
    "notes": "Only populated for labor_internal expenses."
  },
  "expense_end_time": {
    "field": "expenses.end_time",
    "aliases": [
      "clock out",
      "end",
      "finish time"
    ],
    "formula": "Timestamp when time entry ended",
    "notes": "Only populated for labor_internal expenses."
  },
  "expense_category": {
    "field": "expenses.category",
    "aliases": [
      "category",
      "expense type",
      "type"
    ],
    "formula": "ENUM: 'labor_internal' | 'materials' | 'subcontractor' | 'equipment' | etc.",
    "notes": "Critical field for determining expense type and applicable calculations."
  },
  "expense_date": {
    "field": "expenses.expense_date",
    "aliases": [
      "work date",
      "date",
      "expense date",
      "business date"
    ],
    "formula": "Date when the work was performed or expense incurred",
    "notes": "PRIMARY DATE FOR BUSINESS QUERIES. Use this for \"last week's hours\", payroll, financial reporting. This is the business date, not when the entry was created."
  },
  "expense_created_at": {
    "field": "expenses.created_at",
    "aliases": [
      "created",
      "entry date",
      "record created"
    ],
    "formula": "Timestamp when the expense record was created in the system",
    "notes": "When the record was created in the database. NOT the same as when work was done (use expense_date for that) or when it was submitted for approval."
  },
  "expense_submitted_for_approval_at": {
    "field": "expenses.submitted_for_approval_at",
    "aliases": [
      "submitted",
      "submission date",
      "submitted at"
    ],
    "formula": "Timestamp when the expense was submitted for approval",
    "notes": "When the user clicked \"Submit for Approval\". Use for workflow metrics like \"how long has this been pending\"."
  },
  "expense_approved_at": {
    "field": "expenses.approved_at",
    "aliases": [
      "approved",
      "approval date",
      "decision date"
    ],
    "formula": "Timestamp when the expense was approved or rejected",
    "notes": "When the approval decision was made. May be null if status is still pending."
  },
  "quote_quote_amount": {
    "field": "quotes.quote_amount",
    "aliases": [
      "quote amount",
      "quoted price",
      "bid amount",
      "vendor quote"
    ],
    "formula": "Direct field - total quoted to client/vendor",
    "notes": "The base cost quoted by the vendor before any markup."
  },
  "quote_client_amount": {
    "field": "quotes.client_amount",
    "aliases": [
      "client price",
      "selling price",
      "charged amount"
    ],
    "formula": "Amount charged to client (may include markup)",
    "notes": "What the client is charged (quote_amount + markup)."
  },
  "quote_markup_amount": {
    "field": "quotes.markup_amount",
    "aliases": [
      "markup",
      "profit amount",
      "margin amount"
    ],
    "formula": "client_amount - quote_amount",
    "notes": "Profit margin added to vendor quote for client billing."
  },
  "quote_markup_percent": {
    "field": "quotes.markup_percent",
    "aliases": [
      "markup %",
      "profit margin %",
      "margin percent"
    ],
    "formula": "(markup_amount / quote_amount) × 100",
    "notes": "Markup as percentage of vendor quote cost."
  },
  "quote_profit_per_unit": {
    "field": "quotes.profit_per_unit",
    "aliases": [
      "unit profit",
      "profit per item"
    ],
    "formula": "Total profit / quantity (if applicable)",
    "notes": "Profit breakdown per unit when quantity is specified."
  },
  "quote_cost_variance_status": {
    "field": "getCostVarianceStatus()",
    "aliases": [
      "variance status",
      "cost comparison",
      "quote vs actual"
    ],
    "formula": "Compare actual vs quoted costs",
    "notes": "Status indicating if actual costs match quoted amounts."
  },
  "quote_best_quote_per_category": {
    "field": "getBestQuoteForCategory()",
    "aliases": [
      "best quote",
      "lowest bid",
      "cheapest option",
      "optimal quote"
    ],
    "formula": "Lowest quote_amount by category",
    "notes": "Automatically identifies the lowest quote for each category to help with vendor selection."
  },
  "quote_status": {
    "field": "quotes.status",
    "aliases": [
      "status",
      "quote status"
    ],
    "formula": "ENUM: 'pending' | 'accepted' | 'rejected' | 'expired'",
    "notes": "Current status of the quote in the approval process."
  },
  "quote_category": {
    "field": "quotes.category",
    "aliases": [
      "category",
      "type",
      "quote type"
    ],
    "formula": "ENUM: 'materials' | 'labor' | 'equipment' | 'subcontractor' | etc.",
    "notes": "Type of work or materials the quote covers."
  },
  "quote_vendor_name": {
    "field": "quotes.vendor_name",
    "aliases": [
      "vendor",
      "supplier",
      "company"
    ],
    "formula": "Name of the vendor providing the quote",
    "notes": "Human-readable vendor identifier."
  },
  "quote_description": {
    "field": "quotes.description",
    "aliases": [
      "description",
      "details",
      "scope"
    ],
    "formula": "Detailed description of quoted work/materials",
    "notes": "Detailed explanation of what the quote covers."
  },
  "quote_valid_until": {
    "field": "quotes.valid_until",
    "aliases": [
      "expiration",
      "expires",
      "valid date"
    ],
    "formula": "Date until which the quote remains valid",
    "notes": "Quotes may expire and require re-quoting."
  },
  "revenue_invoice_amount": {
    "field": "project_revenues.amount",
    "aliases": [
      "invoice amount",
      "revenue amount",
      "billed amount",
      "amount"
    ],
    "formula": "Direct DB field - individual invoice amount",
    "notes": "The dollar amount of a specific invoice/revenue entry."
  },
  "revenue_invoice_date": {
    "field": "project_revenues.invoice_date",
    "aliases": [
      "invoice date",
      "billed date",
      "date",
      "issued date"
    ],
    "formula": "Direct DB field - when invoice was issued",
    "notes": "Date the invoice was created/issued to the client."
  },
  "revenue_invoice_number": {
    "field": "project_revenues.invoice_number",
    "aliases": [
      "invoice number",
      "invoice #",
      "reference number",
      "invoice ref"
    ],
    "formula": "Direct DB field - QuickBooks invoice reference",
    "notes": "Unique identifier from QuickBooks or internal system."
  },
  "revenue_total_invoiced": {
    "field": "reporting.project_financials.total_invoiced",
    "aliases": [
      "total invoiced",
      "total revenue",
      "invoiced total",
      "revenue received"
    ],
    "formula": "SUM(project_revenues.amount) for direct + SUM(revenue_splits.split_amount) for splits",
    "notes": "Total revenue actually received. Handles split revenues correctly via the view."
  },
  "revenue_invoice_count": {
    "field": "reporting.project_financials.invoice_count",
    "aliases": [
      "invoice count",
      "number of invoices",
      "billing count"
    ],
    "formula": "COUNT(project_revenues) + COUNT(revenue_splits)",
    "notes": "Total number of invoice/revenue records for the project."
  },
  "revenue_revenue_variance": {
    "field": "reporting.project_financials.revenue_variance",
    "aliases": [
      "billing gap",
      "remaining to bill",
      "unbilled amount",
      "revenue gap"
    ],
    "formula": "contracted_amount - total_invoiced",
    "notes": "How much is left to bill. Positive = still owed, Negative = overbilled."
  },
  "revenue_revenue_variance_percent": {
    "field": "reporting.project_financials.revenue_variance_percent",
    "aliases": [
      "billing gap %",
      "revenue variance %"
    ],
    "formula": "(revenue_variance / contracted_amount) × 100",
    "notes": "Revenue variance as percentage of contract value."
  },
  "revenue_split_amount": {
    "field": "revenue_splits.split_amount",
    "aliases": [
      "split amount",
      "allocated revenue",
      "revenue portion"
    ],
    "formula": "Direct DB field - portion allocated to specific project",
    "notes": "Only exists when parent revenue.is_split = true."
  },
  "revenue_split_percentage": {
    "field": "revenue_splits.split_percentage",
    "aliases": [
      "split %",
      "allocation percent",
      "revenue split %"
    ],
    "formula": "(split_amount / parent_revenue.amount) × 100",
    "notes": "Calculated field for display purposes showing allocation percentage."
  },
  "revenue_is_split": {
    "field": "project_revenues.is_split",
    "aliases": [
      "split revenue",
      "allocated revenue",
      "multi-project revenue"
    ],
    "formula": "Boolean flag - true when revenue is allocated across multiple projects",
    "notes": "When true, project_id points to SYS-000 and revenue is split via revenue_splits."
  },
  "revenue_total_revenue_by_project": {
    "field": "calculateProjectRevenue()",
    "aliases": [
      "project revenue",
      "total project revenue",
      "revenue by project"
    ],
    "formula": "SUM(revenues.amount WHERE !is_split) + SUM(revenue_splits.split_amount)",
    "notes": "Combines direct and split revenues for accurate project totals."
  },
  "revenue_status": {
    "field": "project_revenues.status",
    "aliases": [
      "status",
      "payment status",
      "invoice status"
    ],
    "formula": "ENUM: 'pending' | 'sent' | 'paid' | 'overdue' | 'cancelled'",
    "notes": "Current payment/collection status of the revenue."
  },
  "revenue_payment_date": {
    "field": "project_revenues.payment_date",
    "aliases": [
      "payment date",
      "paid date",
      "received date"
    ],
    "formula": "Date when payment was received",
    "notes": "When the client actually paid the invoice."
  },
  "revenue_due_date": {
    "field": "project_revenues.due_date",
    "aliases": [
      "due date",
      "payment due",
      "deadline"
    ],
    "formula": "Date payment is due from client",
    "notes": "When payment is expected from the client."
  },
  "revenue_quickbooks_invoice_id": {
    "field": "project_revenues.quickbooks_invoice_id",
    "aliases": [
      "QB invoice ID",
      "QuickBooks ID",
      "QB reference"
    ],
    "formula": "QuickBooks internal ID for the invoice",
    "notes": "Internal QuickBooks reference for API operations."
  },
  "change_order_amount": {
    "field": "change_orders.amount",
    "aliases": [
      "CO amount",
      "change amount",
      "cost impact",
      "impact amount"
    ],
    "formula": "Direct field - CO cost impact amount",
    "notes": "The dollar impact of the change order on project costs."
  },
  "change_order_client_amount": {
    "field": "change_orders.client_amount",
    "aliases": [
      "client amount",
      "charged amount",
      "billing amount"
    ],
    "formula": "Amount charged to client for the change",
    "notes": "What the client is charged for this change order."
  },
  "change_order_cost_impact": {
    "field": "change_orders.cost_impact",
    "aliases": [
      "cost impact",
      "additional cost",
      "cost change"
    ],
    "formula": "Change to project costs (same as amount field)",
    "notes": "How much this change adds to RCG's costs."
  },
  "change_order_margin_impact": {
    "field": "change_orders.margin_impact",
    "aliases": [
      "margin impact",
      "profit impact",
      "margin change"
    ],
    "formula": "client_amount - cost_impact",
    "notes": "Profit impact of the change order (client_amount - cost_impact)."
  },
  "change_order_contingency_billed_to_client": {
    "field": "change_orders.contingency_billed_to_client",
    "aliases": [
      "contingency billed",
      "recovered contingency",
      "contingency recovery"
    ],
    "formula": "Portion of contingency recovered from client",
    "notes": "Amount of project contingency that was billed to the client as part of this change."
  },
  "change_order_includes_contingency": {
    "field": "change_orders.includes_contingency",
    "aliases": [
      "uses contingency",
      "contingency included",
      "from contingency"
    ],
    "formula": "Boolean flag indicating contingency usage",
    "notes": "Whether this change order utilizes project contingency."
  },
  "change_order_status": {
    "field": "change_orders.status",
    "aliases": [
      "CO status",
      "approval status",
      "status"
    ],
    "formula": "ENUM: 'draft' | 'submitted' | 'approved' | 'rejected' | 'cancelled'",
    "notes": "Current approval status of the change order."
  },
  "change_order_type": {
    "field": "change_orders.type",
    "aliases": [
      "CO type",
      "change type",
      "type"
    ],
    "formula": "ENUM: 'addition' | 'deduction' | 'modification' | 'time_extension'",
    "notes": "Type of change being requested."
  },
  "change_order_description": {
    "field": "change_orders.description",
    "aliases": [
      "description",
      "details",
      "explanation",
      "scope"
    ],
    "formula": "Detailed explanation of the change",
    "notes": "Human-readable description of what the change entails."
  },
  "change_order_requested_by": {
    "field": "change_orders.requested_by",
    "aliases": [
      "requester",
      "requested by",
      "initiated by"
    ],
    "formula": "User ID of person who requested the change",
    "notes": "Who initiated this change order request."
  },
  "change_order_approved_by": {
    "field": "change_orders.approved_by",
    "aliases": [
      "approver",
      "approved by",
      "authorized by"
    ],
    "formula": "User ID of person who approved the change",
    "notes": "Who approved this change order."
  },
  "change_order_approved_at": {
    "field": "change_orders.approved_at",
    "aliases": [
      "approved date",
      "approval date",
      "approved at"
    ],
    "formula": "Timestamp when change was approved",
    "notes": "When the change order was officially approved."
  },
  "change_order_submitted_at": {
    "field": "change_orders.submitted_at",
    "aliases": [
      "submitted date",
      "submission date",
      "submitted at"
    ],
    "formula": "Timestamp when change was submitted for approval",
    "notes": "When the change order was submitted for approval."
  },
  "change_order_project_impact": {
    "field": "calculateChangeOrderImpact()",
    "aliases": [
      "impact",
      "project impact",
      "effect on project"
    ],
    "formula": "Combined impact on project timeline and budget",
    "notes": "Overall assessment of how the change affects the project."
  },
  "change_order_schedule_impact_days": {
    "field": "change_orders.schedule_impact_days",
    "aliases": [
      "schedule impact",
      "timeline impact",
      "days added"
    ],
    "formula": "Number of days added to project timeline",
    "notes": "How many days this change adds to the project duration."
  },
  "work_order_count": {
    "field": "statistics.total",
    "aliases": [
      "total work orders",
      "WO count",
      "number of work orders"
    ],
    "formula": "COUNT(projects WHERE project_type = 'work_order')",
    "notes": "Total number of work orders across all projects."
  },
  "work_order_pending_in_progress": {
    "field": "statistics.pendingInProgress",
    "aliases": [
      "active work orders",
      "in progress WOs",
      "current work orders"
    ],
    "formula": "COUNT(WOs WHERE status IN ('in_progress', 'estimating', 'quoted'))",
    "notes": "Work orders currently being worked on or in process."
  },
  "work_order_completed_this_week": {
    "field": "statistics.completedThisWeek",
    "aliases": [
      "weekly completions",
      "this week completions"
    ],
    "formula": "COUNT(WOs WHERE status = 'complete' AND end_date >= weekStart)",
    "notes": "Work orders completed in the current week."
  },
  "work_order_completed_this_month": {
    "field": "statistics.completedThisMonth",
    "aliases": [
      "monthly completions",
      "this month completions"
    ],
    "formula": "COUNT(WOs WHERE status = 'complete' AND end_date >= monthStart)",
    "notes": "Work orders completed in the current month."
  },
  "work_order_has_real_estimate": {
    "field": "has_estimate && !is_auto_generated_estimate",
    "aliases": [
      "real estimate",
      "valid estimate",
      "proper estimate"
    ],
    "formula": "Excludes system-created placeholder estimates",
    "notes": "Whether the work order has a real estimate (not auto-generated placeholder)."
  },
  "work_order_total_expenses": {
    "field": "workOrder.total_expenses",
    "aliases": [
      "WO expenses",
      "work order costs",
      "total costs"
    ],
    "formula": "SUM(expenses.amount WHERE project_id = WO)",
    "notes": "All expenses incurred on this work order."
  },
  "work_order_expense_count": {
    "field": "workOrder.expense_count",
    "aliases": [
      "expense count",
      "number of expenses"
    ],
    "formula": "COUNT(expenses WHERE project_id = WO)",
    "notes": "Number of expense transactions for this work order."
  },
  "work_order_dne_utilization_percent": {
    "field": "calculateDNEUtilization()",
    "aliases": [
      "budget utilization",
      "DNE %",
      "budget used %"
    ],
    "formula": "(Total Expenses / Do Not Exceed) × 100",
    "notes": "Percentage of budget cap that has been used."
  },
  "work_order_number": {
    "field": "generateWorkOrderNumber()",
    "aliases": [
      "WO number",
      "work order #",
      "WO ID"
    ],
    "formula": "{project_number}-WO-{counter}",
    "notes": "Unique identifier for work orders under a project."
  },
  "work_order_do_not_exceed": {
    "field": "projects.do_not_exceed",
    "aliases": [
      "DNE",
      "budget cap",
      "max budget",
      "WO limit"
    ],
    "formula": "Maximum billable amount (work orders only)",
    "notes": "CRITICAL: Budget cap for work orders. Expenses should not exceed this amount."
  },
  "work_order_customer_po_number": {
    "field": "projects.customer_po_number",
    "aliases": [
      "PO number",
      "customer PO",
      "client PO"
    ],
    "formula": "Client reference number",
    "notes": "Purchase order number provided by the client."
  },
  "work_order_counter": {
    "field": "projects.work_order_counter",
    "aliases": [
      "WO counter",
      "counter",
      "sequence"
    ],
    "formula": "Auto-incrementing per project",
    "notes": "Sequential counter for work orders under each project."
  },
  "work_order_original_est_costs": {
    "field": "projects.original_est_costs",
    "aliases": [
      "original estimate",
      "baseline costs",
      "initial costs"
    ],
    "formula": "Initial cost estimate at work order creation",
    "notes": "Immutable baseline cost estimate set when work order was created."
  },
  "work_order_adjusted_est_costs": {
    "field": "projects.adjusted_est_costs",
    "aliases": [
      "current estimate",
      "adjusted costs",
      "revised costs"
    ],
    "formula": "Original Est. Costs + Change Order Costs",
    "notes": "Current expected costs including approved changes."
  },
  "work_order_projected_margin": {
    "field": "projects.projected_margin",
    "aliases": [
      "projected margin",
      "expected margin",
      "forecast margin"
    ],
    "formula": "contracted_amount - adjusted_est_costs",
    "notes": "Expected final margin based on current estimates."
  },
  "work_order_contracted_amount": {
    "field": "projects.contracted_amount",
    "aliases": [
      "contract amount",
      "agreed amount",
      "WO value"
    ],
    "formula": "Total contract value with client",
    "notes": "What the client agreed to pay for this work order."
  },
  "work_order_status": {
    "field": "projects.status",
    "aliases": [
      "status",
      "WO status"
    ],
    "formula": "ENUM: 'estimating' | 'quoted' | 'approved' | 'in_progress' | 'complete'",
    "notes": "Current status of the work order in the process."
  },
  "work_order_project_type": {
    "field": "projects.project_type",
    "aliases": [
      "type",
      "project type"
    ],
    "formula": "'work_order' (constant for work orders)",
    "notes": "Always \"work_order\" for work order records."
  },
  "work_order_category": {
    "field": "projects.category",
    "aliases": [
      "category",
      "WO category"
    ],
    "formula": "'construction' | 'system' | 'overhead'",
    "notes": "Controls which work orders are visible in different contexts."
  },
  "work_order_start_date": {
    "field": "projects.start_date",
    "aliases": [
      "start",
      "began",
      "started"
    ],
    "formula": "When work order work began",
    "notes": "Actual start date of work order execution."
  },
  "work_order_end_date": {
    "field": "projects.end_date",
    "aliases": [
      "end",
      "completed",
      "finished"
    ],
    "formula": "When work order was completed",
    "notes": "Date when work order reached completion status."
  },
  "work_order_created_at": {
    "field": "projects.created_at",
    "aliases": [
      "created",
      "creation date"
    ],
    "formula": "When work order was first created",
    "notes": "Timestamp of work order creation in the system."
  },
  "deprecated_project_budget": {
    "field": "projects.budget",
    "aliases": [
      "budget",
      "old budget"
    ],
    "formula": "Replaced by contracted_amount",
    "notes": "Legacy field replaced by contracted_amount. Use contracted_amount instead."
  },
  "deprecated_estimate_rate": {
    "field": "estimate_line_items.rate",
    "aliases": [
      "rate",
      "old rate",
      "line rate"
    ],
    "formula": "Replaced by price_per_unit",
    "notes": "Legacy field replaced by price_per_unit. Use price_per_unit instead."
  },
  "deprecated_old_revenue_calculations": {
    "field": "Various legacy fields",
    "aliases": [
      "old revenue",
      "legacy revenue",
      "old invoicing"
    ],
    "formula": "See project_revenues table",
    "notes": "Revenue tracking moved to dedicated project_revenues table. Use total_invoiced instead."
  },
  "deprecated_old_expense_tracking": {
    "field": "Legacy expense fields",
    "aliases": [
      "old expenses",
      "legacy expenses"
    ],
    "formula": "See expenses table",
    "notes": "Expense tracking moved to dedicated expenses table with proper categorization."
  },
  "deprecated_old_quote_system": {
    "field": "Legacy quote fields",
    "aliases": [
      "old quotes",
      "legacy quotes"
    ],
    "formula": "See quotes table",
    "notes": "Quote system moved to dedicated quotes table with proper vendor management."
  },
  "deprecated_old_change_order_tracking": {
    "field": "Legacy CO fields",
    "aliases": [
      "old COs",
      "legacy change orders"
    ],
    "formula": "See change_orders table",
    "notes": "Change order tracking moved to dedicated change_orders table."
  },
  "deprecated_old_work_order_fields": {
    "field": "Legacy WO fields",
    "aliases": [
      "old WOs",
      "legacy work orders"
    ],
    "formula": "See projects table with project_type filtering",
    "notes": "Work orders now use regular projects table with project_type = 'work_order'."
  }
},

  // Disambiguation guide for commonly confused terms
  disambiguationGuide: [
  "MARGIN DISAMBIGUATION:",
  "- \"profit\", \"real profit\", \"actual profit\" → actual_margin (total_invoiced - total_expenses)",
  "- \"margin\", \"expected margin\" → current_margin (contracted_amount - total_expenses)",
  "- \"projected margin\", \"forecast\" → projected_margin (contracted_amount - adjusted_est_costs)",
  "- \"original margin\", \"baseline\" → original_margin (contracted_amount - original_est_costs)",
  "",
  "DATE FIELD DISAMBIGUATION:",
  "- \"when did they work\", \"work date\", \"last week hours\" → expense_date (business date)",
  "- \"when was this entered\", \"record created\" → created_at (audit timestamp)",
  "- \"when submitted\", \"pending duration\" → submitted_for_approval_at",
  "- \"when approved\", \"approval date\" → approved_at",
  "",
  "HOURS DISAMBIGUATION:",
  "- \"hours worked\", \"billable hours\" → net hours (gross - lunch)",
  "- \"shift length\", \"total time\", \"overtime check\" → gross hours (end_time - start_time)",
  "",
  "REVENUE DISAMBIGUATION:",
  "- \"revenue\", \"billed\", \"collected\" → total_invoiced (actual received)",
  "- \"contract value\", \"deal size\" → contracted_amount (expected)",
  "- \"remaining to bill\", \"unbilled\" → revenue_variance (contracted - invoiced)"
],

  // Critical business rules the AI must follow
  criticalRules: [
  "Use `reporting.project_financials` view for project financial queries instead of raw `projects` table",
  "NEVER use the receipts table for financial calculations - receipts are documentation only",
  "Time entries are stored in the `expenses` table with category = 'labor_internal'",
  "Always filter projects by category = 'construction' unless user specifically asks for overhead or system projects",
  "To find employees, use payees table WHERE is_internal = true",
  "Vendors are material suppliers (payee_type='vendor'). Subcontractors are trade contractors (payee_type='subcontractor').",
  "Cost = what RCG pays to vendors/workers. Price = what clients are charged.",
  "actual_margin = invoiced - expenses (REAL profit). current_margin = contracted - expenses (EXPECTED profit).",
  "Use pre-calculated fields from the reporting view or projects table instead of recalculating in queries. Prefer reporting.project_financials for multi-project queries; projects table is OK for single project lookups.",
  "The view `project_financial_summary` is deprecated. Use `reporting.project_financials` instead.",
  "All vendors, subcontractors, and employees are in the `payees` table. There is no separate vendors or employees table.",
  "Use ILIKE with wildcards for name searches. Names may have variations (John vs John Smith vs J. Smith).",
  "The reporting.project_financials view handles expense and revenue splits correctly. Do not try to manually aggregate.",
  "When querying estimates for financial data, filter by status = 'approved' AND is_current_version = true",
  "Only SELECT queries are allowed. No INSERT, UPDATE, DELETE, DROP, or DDL statements."
],

  // Few-shot examples for query generation
  fewShotExamples: [
  {
    "question": "What's our total profit this month?",
    "reasoning": "User wants actual realized profit. Use actual_margin (invoiced - expenses) from the reporting view. Filter to current month and construction projects only.",
    "sql": "SELECT\n  SUM(actual_margin) as total_profit,\n  COUNT(*) as project_count\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND start_date >= DATE_TRUNC('month', CURRENT_DATE)"
  },
  {
    "question": "How much have we spent on materials this year?",
    "reasoning": "Looking for expense totals by category. Use expenses table filtered to materials category and current year.",
    "sql": "SELECT\n  SUM(e.amount) as total_materials,\n  COUNT(*) as expense_count\nFROM expenses e\nWHERE e.category = 'materials'\n  AND e.expense_date >= DATE_TRUNC('year', CURRENT_DATE)"
  },
  {
    "question": "What's our average margin percentage across all active projects?",
    "reasoning": "Need margin_percentage from projects that are in progress. Use the reporting view.",
    "sql": "SELECT\n  AVG(margin_percentage) as avg_margin_percent,\n  MIN(margin_percentage) as min_margin,\n  MAX(margin_percentage) as max_margin,\n  COUNT(*) as project_count\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status IN ('in_progress', 'approved')"
  },
  {
    "question": "Show me projects over budget",
    "reasoning": "Over budget means cost_variance > 0. Use the reporting view which calculates this.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  cost_variance,\n  cost_variance_percent,\n  budget_utilization_percent\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND cost_variance > 0\nORDER BY cost_variance DESC"
  },
  {
    "question": "Which projects have low margins?",
    "reasoning": "Low margin typically means below 15-20%. Filter by margin_percentage.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  current_margin,\n  margin_percentage,\n  status\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND margin_percentage < 15\n  AND status NOT IN ('cancelled', 'on_hold')\nORDER BY margin_percentage ASC"
  },
  {
    "question": "Find projects with remaining contingency",
    "reasoning": "Check contingency_remaining > 0 for available buffer.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  contingency_amount,\n  contingency_used,\n  contingency_remaining\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND contingency_remaining > 0\nORDER BY contingency_remaining DESC"
  },
  {
    "question": "How many hours did John work last week?",
    "reasoning": "Time entries are in expenses table with category='labor_internal'. Calculate hours from start_time/end_time minus lunch. Use ILIKE for fuzzy name matching. Join to payees for employee info.",
    "sql": "SELECT\n  p.payee_name,\n  SUM(\n    CASE\n      WHEN e.lunch_taken = true THEN\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600) - (e.lunch_duration_minutes / 60.0)\n      ELSE\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600)\n    END\n  ) as total_hours,\n  SUM(e.amount) as total_billed\nFROM expenses e\nJOIN payees p ON e.payee_id = p.id\nWHERE p.is_internal = true\n  AND p.payee_name ILIKE '%john%'\n  AND e.category = 'labor_internal'\n  AND e.expense_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY p.payee_name"
  },
  {
    "question": "Show me all employee hours this month by person",
    "reasoning": "Aggregate time entries by employee. Calculate net billable hours from start_time/end_time minus lunch. Filter to internal payees only.",
    "sql": "SELECT\n  p.payee_name as employee,\n  SUM(\n    CASE\n      WHEN e.lunch_taken = true THEN\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600) - (e.lunch_duration_minutes / 60.0)\n      ELSE\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600)\n    END\n  ) as total_hours,\n  COUNT(DISTINCT e.project_id) as projects_worked,\n  SUM(e.amount) as total_billed\nFROM expenses e\nJOIN payees p ON e.payee_id = p.id\nWHERE p.is_internal = true\n  AND e.category = 'labor_internal'\n  AND e.expense_date >= DATE_TRUNC('month', CURRENT_DATE)\nGROUP BY p.payee_name\nORDER BY total_hours DESC"
  },
  {
    "question": "Show me employees who worked over 8 hour shifts this week",
    "reasoning": "Use gross_hours (total shift duration) not hours (net billable). This is about shift length for compliance, not billable hours.",
    "sql": "SELECT\n  p.payee_name as employee,\n  e.expense_date as work_date,\n  EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600 as gross_hours,\n  CASE\n    WHEN e.lunch_taken = true THEN\n      (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600) - (e.lunch_duration_minutes / 60.0)\n    ELSE\n      (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600)\n  END as net_hours\nFROM expenses e\nJOIN payees p ON e.payee_id = p.id\nWHERE e.category = 'labor_internal'\n  AND e.expense_date >= CURRENT_DATE - INTERVAL '7 days'\n  AND EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600 > 8\nORDER BY gross_hours DESC"
  },
  {
    "question": "Compare expected vs actual revenue for active projects",
    "reasoning": "contracted_amount is expected, total_invoiced is actual. Calculate the gap.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  contracted_amount as expected_revenue,\n  total_invoiced as actual_revenue,\n  revenue_variance as remaining_to_bill,\n  CASE\n    WHEN contracted_amount > 0\n    THEN ROUND((total_invoiced / contracted_amount * 100)::numeric, 1)\n    ELSE 0\n  END as billing_progress_percent\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status IN ('in_progress', 'approved')\nORDER BY revenue_variance DESC"
  },
  {
    "question": "How do our original estimates compare to actual costs?",
    "reasoning": "Compare original_est_costs to total_expenses. Calculate variance.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  original_est_costs as estimated,\n  total_expenses as actual,\n  (total_expenses - original_est_costs) as variance,\n  CASE\n    WHEN original_est_costs > 0\n    THEN ROUND(((total_expenses - original_est_costs) / original_est_costs * 100)::numeric, 1)\n    ELSE 0\n  END as variance_percent\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status IN ('complete', 'in_progress')\n  AND original_est_costs > 0\nORDER BY variance DESC"
  },
  {
    "question": "What's the status of the Smith project?",
    "reasoning": "Lookup by partial project or client name using ILIKE.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  client_name,\n  status,\n  contracted_amount,\n  total_expenses,\n  current_margin,\n  margin_percentage\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND (project_name ILIKE '%smith%' OR client_name ILIKE '%smith%')"
  },
  {
    "question": "Show me all expenses for project 2024-001",
    "reasoning": "Direct lookup by project number. Get expense details.",
    "sql": "SELECT\n  e.expense_date,\n  e.category,\n  e.amount,\n  e.description,\n  p.payee_name as vendor\nFROM expenses e\nLEFT JOIN payees p ON e.payee_id = p.id\nWHERE e.project_id = (\n  SELECT id FROM projects WHERE project_number = '2024-001'\n)\nORDER BY e.expense_date DESC"
  },
  {
    "question": "What projects did we complete last quarter?",
    "reasoning": "Filter by status='complete' and end_date in previous quarter.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  client_name,\n  end_date,\n  contracted_amount,\n  total_invoiced,\n  actual_margin,\n  margin_percentage\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status = 'complete'\n  AND end_date >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n  AND end_date < DATE_TRUNC('quarter', CURRENT_DATE)\nORDER BY end_date DESC"
  },
  {
    "question": "Show me expenses from yesterday",
    "reasoning": "Simple date filter on expenses table.",
    "sql": "SELECT\n  e.expense_date,\n  proj.project_number,\n  e.category,\n  e.amount,\n  e.description,\n  p.payee_name\nFROM expenses e\nJOIN projects proj ON e.project_id = proj.id\nLEFT JOIN payees p ON e.payee_id = p.id\nWHERE e.expense_date = CURRENT_DATE - INTERVAL '1 day'\nORDER BY e.amount DESC"
  }
],

  // Business benchmarks for contextual insights
  benchmarks: {
  "project_margin": {
    "healthy": "15-30%",
    "warning": ">10%",
    "critical": ">5%"
  },
  "cost_variance": {
    "healthy": "-5-5%",
    "warning": ">10%",
    "critical": ">20%"
  },
  "budget_progress": {
    "healthy": "70-100%",
    "warning": ">50%"
  },
  "labor_cushion_rate": {
    "healthy": "35-50",
    "warning": "n/a"
  },
  "contingency_usage": {
    "healthy": "0-50%",
    "warning": ">75%",
    "critical": ">100%"
  },
  "weekly_hours": {
    "healthy": "35-45",
    "warning": ">50"
  }
},

  // Preferred data sources
  preferredSources: {
    'project financials': 'reporting.project_financials',
    'time entries': "expenses WHERE category = 'labor_internal'",
    'employees': 'payees WHERE is_internal = true',
    'vendors': "payees WHERE payee_type = 'vendor' AND is_internal = false",
    'subcontractors': "payees WHERE payee_type = 'subcontractor' AND is_internal = false",
  },
} as const;

export type KPIContext = typeof KPI_CONTEXT;
