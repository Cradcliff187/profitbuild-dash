/**
 * AUTO-GENERATED KPI CONTEXT FOR EDGE FUNCTION
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 *
 * Generated by: scripts/sync-edge-kpi-context.ts
 * Generated at: 2026-01-30T01:15:05.817Z
 * Source version: 3.0.0
 * Source last updated: 2026-01-28
 *
 * To regenerate, run: npx tsx scripts/sync-edge-kpi-context.ts
 *
 * KPI Counts:
 * - Project: 28
 * - Estimate: 23
 * - Expense: 25
 * - Quote: 12
 * - Revenue: 15
 * - Change Order: 15
 * - Work Order: 22
 * - View: 21
 * - Time Entry: 21
 * - Payee: 24
 * - Deprecated: 10
 * - TOTAL: 216
 */

export const KPI_CONTEXT = {
  version: '3.0.0',
  generatedAt: '2026-01-30T01:15:05.817Z',
  sourceLastUpdated: '2026-01-28',

  // Semantic lookup: business term -> database field
  semanticLookup: {
  "profit": "projects.actual_margin",
  "earnings": "projects.actual_margin",
  "made": "projects.actual_margin",
  "earned": "projects.actual_margin",
  "net": "projects.actual_margin",
  "bottom line": "projects.actual_margin",
  "money made": "projects.actual_margin",
  "margin": "projects.adjusted_est_margin",
  "markup": "projects.adjusted_est_margin",
  "spread": "projects.adjusted_est_margin",
  "profit margin": "projects.adjusted_est_margin",
  "projected margin": "projects.adjusted_est_margin",
  "expected margin": "projects.adjusted_est_margin",
  "forecast margin": "projects.adjusted_est_margin",
  "estimated margin": "projects.adjusted_est_margin",
  "projected profit": "projects.adjusted_est_margin",
  "revenue": "reporting.project_financials.total_invoiced",
  "income": "reporting.project_financials.total_invoiced",
  "sales": "reporting.project_financials.total_invoiced",
  "money coming in": "reporting.project_financials.total_invoiced",
  "billed": "reporting.project_financials.total_invoiced",
  "contract": "projects.contracted_amount",
  "contract value": "projects.contracted_amount",
  "deal size": "projects.contracted_amount",
  "project value": "projects.contracted_amount",
  "contract amount": "projects.contracted_amount",
  "invoiced": "reporting.project_financials.total_invoiced",
  "collected": "reporting.project_financials.total_invoiced",
  "received": "reporting.project_financials.total_invoiced",
  "paid by client": "reporting.project_financials.total_invoiced",
  "costs": "reporting.project_financials.total_expenses",
  "expenses": "reporting.project_financials.total_expenses",
  "spending": "reporting.project_financials.total_expenses",
  "spent": "reporting.project_financials.total_expenses",
  "paid out": "reporting.project_financials.total_expenses",
  "outgoing": "reporting.project_financials.total_expenses",
  "budget": "projects.adjusted_est_costs",
  "estimated costs": "projects.adjusted_est_costs",
  "cost estimate": "projects.adjusted_est_costs",
  "projected costs": "projects.adjusted_est_costs",
  "over budget": "reporting.project_financials.cost_variance",
  "budget overrun": "reporting.project_financials.cost_variance",
  "cost overrun": "reporting.project_financials.cost_variance",
  "overspent": "reporting.project_financials.cost_variance",
  "employee": "payees.payee_name",
  "worker": "payees.payee_name",
  "staff": "payees.payee_name",
  "team member": "payees.payee_name",
  "field worker": "payees.payee_name",
  "crew": "payees.payee_name",
  "hours": "expenses.hours",
  "time": "expenses.hours",
  "worked": "expenses.hours",
  "labor hours": "expenses.hours",
  "overtime": "CALCULATED: (end_time - start_time) / 3600",
  "ot": "CALCULATED: (end_time - start_time) / 3600",
  "extra hours": "CALCULATED: (end_time - start_time) / 3600",
  "over 8 hours": "CALCULATED: (end_time - start_time) / 3600",
  "vendor": "payees.payee_name",
  "supplier": "payees.payee_name",
  "material supplier": "payees.payee_name",
  "materials vendor": "payees.payee_name",
  "subcontractor": "payees.payee_name",
  "sub": "payees.payee_name",
  "contractor": "payees.payee_name",
  "trade contractor": "payees.payee_name",
  "quotes": "quote_total_amount",
  "bids": "quote_total_amount",
  "proposals": "quote_total_amount",
  "estimates from vendors": "quote_total_amount",
  "contingency": "projects.contingency_remaining",
  "buffer": "projects.contingency_remaining",
  "reserve": "projects.contingency_remaining",
  "safety margin": "projects.contingency_remaining",
  "cushion": "projects.contingency_remaining",
  "change orders": "reporting.project_financials.change_order_count",
  "cos": "reporting.project_financials.change_order_count",
  "scope changes": "reporting.project_financials.change_order_count",
  "modifications": "reporting.project_financials.change_order_count",
  "change requests": "reporting.project_financials.change_order_count",
  "time entries": "expenses.hours",
  "timesheets": "expenses.hours",
  "time records": "expenses.hours",
  "labor entries": "expenses.hours",
  "clock entries": "expenses.hours",
  "pending approval": "expenses.approval_status",
  "unapproved": "expenses.approval_status",
  "awaiting approval": "expenses.approval_status",
  "needs approval": "expenses.approval_status",
  "active projects": "projects.status",
  "in progress": "projects.status",
  "ongoing": "projects.status",
  "current projects": "projects.status",
  "completed projects": "projects.status",
  "finished": "projects.status",
  "done": "projects.status",
  "closed projects": "projects.status"
},

  // KPI definitions with aliases and formulas
  kpiDefinitions: {
  "contracted_amount": {
    "field": "projects.contracted_amount",
    "aliases": [
      "contract value",
      "contract amount",
      "total contract",
      "revenue",
      "contract"
    ],
    "formula": "Base estimate amount + approved change order client amounts",
    "notes": "Total contract value with client. Updated by triggers when estimates approved or change orders accepted."
  },
  "total_invoiced": {
    "field": "reporting.project_financials.total_invoiced",
    "aliases": [
      "invoiced",
      "billed",
      "actual revenue",
      "received",
      "collected"
    ],
    "formula": "SUM(project_revenues.amount) for direct + SUM(revenue_splits.split_amount) for splits",
    "notes": "Actual revenue received. Handles split invoices correctly via the view."
  },
  "invoice_count": {
    "field": "reporting.project_financials.invoice_count",
    "aliases": [],
    "formula": "COUNT(project_revenues) + COUNT(revenue_splits)",
    "notes": "Total number of invoices/revenue entries for the project."
  },
  "revenue_variance": {
    "field": "reporting.project_financials.revenue_variance",
    "aliases": [
      "billing gap",
      "remaining to bill",
      "unbilled"
    ],
    "formula": "contracted_amount - total_invoiced",
    "notes": "How much is left to bill. Positive = still owed, Negative = overbilled."
  },
  "adjusted_est_margin": {
    "field": "projects.adjusted_est_margin",
    "aliases": [
      "projected margin",
      "expected margin",
      "forecast margin",
      "est margin"
    ],
    "formula": "contracted_amount - adjusted_est_costs",
    "notes": "Expected final margin based on current estimates (adjusted for accepted quotes and change orders). This is the PRIMARY margin metric for forecasting."
  },
  "current_margin": {
    "field": "projects.current_margin",
    "aliases": [
      "margin"
    ],
    "formula": "contracted_amount - total_expenses",
    "notes": "DEPRECATED: Use actual_margin instead. This field mixed concepts and will be removed."
  },
  "actual_margin": {
    "field": "projects.actual_margin",
    "aliases": [
      "real margin",
      "real profit",
      "actual profit",
      "profit",
      "true margin"
    ],
    "formula": "total_invoiced - total_expenses",
    "notes": "REAL profit based on actual invoices received minus actual expenses. This is true realized profit."
  },
  "original_margin": {
    "field": "projects.original_margin",
    "aliases": [
      "baseline margin",
      "initial margin"
    ],
    "formula": "contracted_amount - original_est_costs",
    "notes": "Margin from original approved estimate. Immutable baseline for comparison."
  },
  "projected_margin": {
    "field": "projects.projected_margin",
    "aliases": [
      "forecast margin"
    ],
    "formula": "contracted_amount - adjusted_est_costs",
    "notes": "DEPRECATED: Renamed to adjusted_est_margin for clarity. Both columns exist during transition."
  },
  "margin_percentage": {
    "field": "projects.margin_percentage",
    "aliases": [
      "margin %",
      "margin percent",
      "profit margin %"
    ],
    "formula": "(adjusted_est_margin / contracted_amount) × 100",
    "notes": "Adjusted estimated margin as percentage of contract value. Based on adjusted_est_margin."
  },
  "adjusted_est_margin_percent": {
    "field": "reporting.project_financials.adjusted_est_margin_percent",
    "aliases": [
      "projected margin %",
      "forecast margin %"
    ],
    "formula": "(adjusted_est_margin / contracted_amount) × 100",
    "notes": "Adjusted estimated margin as percentage. Same as margin_percentage but explicit naming."
  },
  "actual_margin_percent": {
    "field": "reporting.project_financials.actual_margin_percent",
    "aliases": [
      "real margin %",
      "true margin %",
      "profit %"
    ],
    "formula": "(actual_margin / total_invoiced) × 100",
    "notes": "Actual realized margin as percentage of actual revenue. For completed/invoiced projects."
  },
  "total_expenses": {
    "field": "reporting.project_financials.total_expenses",
    "aliases": [
      "costs",
      "actual costs",
      "expenses",
      "spent",
      "actual expenses"
    ],
    "formula": "SUM(expenses.amount) for direct + SUM(expense_splits.split_amount) for splits",
    "notes": "All actual costs incurred. Handles split expenses correctly via the view."
  },
  "original_est_costs": {
    "field": "projects.original_est_costs",
    "aliases": [
      "original costs",
      "baseline costs",
      "initial estimate",
      "original est"
    ],
    "formula": "SUM(estimate_line_items.total_cost) from original approved estimate",
    "notes": "Immutable baseline cost estimate. Set when estimate first approved. Uses COSTS not prices."
  },
  "adjusted_est_costs": {
    "field": "projects.adjusted_est_costs",
    "aliases": [
      "current estimate",
      "revised costs",
      "budget",
      "adjusted costs",
      "est costs"
    ],
    "formula": "original_est_costs + accepted_quote_variances + change_order_costs",
    "notes": "Current expected costs including all approved changes. Quote costs replace original line item costs."
  },
  "cost_variance": {
    "field": "reporting.project_financials.cost_variance",
    "aliases": [
      "budget variance",
      "over/under budget"
    ],
    "formula": "total_expenses - adjusted_est_costs",
    "notes": "Positive = over budget, Negative = under budget (savings)."
  },
  "cost_variance_percent": {
    "field": "reporting.project_financials.cost_variance_percent",
    "aliases": [
      "variance %"
    ],
    "formula": "(cost_variance / adjusted_est_costs) × 100",
    "notes": "Cost variance as percentage of budget."
  },
  "budget_utilization_percent": {
    "field": "reporting.project_financials.budget_utilization_percent",
    "aliases": [
      "budget used",
      "burn rate",
      "budget consumed"
    ],
    "formula": "(total_expenses / adjusted_est_costs) × 100",
    "notes": "Percentage of budget consumed. 100% = on budget, >100% = over budget."
  },
  "contingency_amount": {
    "field": "estimates.contingency_amount",
    "aliases": [
      "contingency",
      "buffer",
      "reserve"
    ],
    "formula": "Contingency set in approved estimate",
    "notes": "Total contingency buffer from approved estimate."
  },
  "contingency_used": {
    "field": "projects.contingency_used",
    "aliases": [],
    "formula": "SUM(change_orders.cost_impact WHERE includes_contingency = true)",
    "notes": "How much contingency has been consumed by change orders."
  },
  "contingency_remaining": {
    "field": "projects.contingency_remaining",
    "aliases": [
      "available contingency"
    ],
    "formula": "contingency_amount - contingency_used",
    "notes": "Available contingency buffer."
  },
  "target_margin": {
    "field": "projects.target_margin",
    "aliases": [],
    "formula": "User-defined goal amount",
    "notes": "Desired margin goal for the project."
  },
  "minimum_margin_threshold": {
    "field": "projects.minimum_margin_threshold",
    "aliases": [
      "margin floor",
      "minimum margin"
    ],
    "formula": "User-defined floor amount (alert threshold)",
    "notes": "Below this triggers warnings."
  },
  "change_order_revenue": {
    "field": "reporting.project_financials.change_order_revenue",
    "aliases": [
      "CO revenue"
    ],
    "formula": "SUM(change_orders.client_amount WHERE status = approved)",
    "notes": "Total revenue added from approved change orders."
  },
  "change_order_cost": {
    "field": "reporting.project_financials.change_order_cost",
    "aliases": [
      "CO cost"
    ],
    "formula": "SUM(change_orders.cost_impact WHERE status = approved)",
    "notes": "Total cost added from approved change orders."
  },
  "change_order_count": {
    "field": "reporting.project_financials.change_order_count",
    "aliases": [],
    "formula": "COUNT(change_orders WHERE status = approved)",
    "notes": "Number of approved change orders."
  },
  "project_status": {
    "field": "projects.status",
    "aliases": [
      "status"
    ],
    "formula": "Enum: draft | pending | approved | in_progress | on_hold | complete | cancelled",
    "notes": "Current project status."
  },
  "project_category": {
    "field": "projects.category",
    "aliases": [
      "category"
    ],
    "formula": "Enum: construction | overhead | system",
    "notes": "Construction = visible everywhere, Overhead = expenses only, System = internal."
  },
  "estimate_total_amount": {
    "field": "estimates.total_amount",
    "aliases": [
      "estimate amount",
      "total estimate",
      "estimate value"
    ],
    "formula": "SUM(estimate_line_items.total) for approved estimate",
    "notes": "Total estimated amount including markup for client presentation."
  },
  "estimate_total_cost": {
    "field": "estimates.total_cost",
    "aliases": [
      "estimate cost",
      "total cost",
      "estimated cost"
    ],
    "formula": "SUM(estimate_line_items.total_cost) for approved estimate",
    "notes": "For labor items, uses billing rate (not actual cost) to hide cushion. For materials, uses actual vendor cost."
  },
  "estimate_contingency_amount": {
    "field": "estimates.contingency_amount",
    "aliases": [
      "contingency",
      "buffer amount",
      "estimate contingency"
    ],
    "formula": "User-defined or calculated buffer amount",
    "notes": "Additional buffer for unknowns, typically 5-15% of total."
  },
  "estimate_contingency_percent": {
    "field": "estimates.contingency_percent",
    "aliases": [
      "contingency %",
      "buffer percent"
    ],
    "formula": "(contingency_amount / total_amount) × 100"
  },
  "estimate_default_markup_percent": {
    "field": "estimates.default_markup_percent",
    "aliases": [
      "default markup",
      "standard markup"
    ],
    "formula": "User-defined default for line items (typically 10-30%)",
    "notes": "Default markup applied to line items when created."
  },
  "estimate_target_margin_percent": {
    "field": "estimates.target_margin_percent",
    "aliases": [
      "target margin",
      "profit target"
    ],
    "formula": "User-defined profitability goal (typically 15-25%)"
  },
  "estimate_is_auto_generated": {
    "field": "estimates.is_auto_generated",
    "aliases": [
      "auto generated",
      "quick estimate"
    ],
    "formula": "Boolean flag - true when created from Quick Work Order",
    "notes": "Indicates placeholder estimate created automatically."
  },
  "estimate_line_item_total": {
    "field": "estimate_line_items.total",
    "aliases": [
      "line total",
      "item total"
    ],
    "formula": "quantity × price_per_unit",
    "notes": "Total amount for this line item including markup."
  },
  "estimate_line_item_total_cost": {
    "field": "estimate_line_items.total_cost",
    "aliases": [
      "line cost",
      "item cost",
      "actual cost"
    ],
    "formula": "quantity × cost_per_unit"
  },
  "estimate_line_item_markup_amount": {
    "field": "estimate_line_items.markup_amount",
    "aliases": [
      "markup amount",
      "profit amount"
    ],
    "formula": "total - total_cost"
  },
  "estimate_line_item_markup_percent": {
    "field": "estimate_line_items.markup_percent",
    "aliases": [
      "markup %",
      "profit margin %"
    ],
    "formula": "(markup_amount / total_cost) × 100"
  },
  "estimate_labor_hours": {
    "field": "estimate_line_items.labor_hours",
    "aliases": [
      "labor hours",
      "hours",
      "estimated hours"
    ],
    "formula": "Hours for labor_internal line items only",
    "notes": "Only populated for labor_internal category. Used for time tracking and resource planning."
  },
  "estimate_billing_rate_per_hour": {
    "field": "estimate_line_items.billing_rate_per_hour",
    "aliases": [
      "billing rate",
      "hourly rate",
      "client rate"
    ],
    "formula": "Rate shown to client (e.g., $75/hr)",
    "notes": "What the client is charged per hour. Used as cost_per_unit to hide actual labor cost."
  },
  "estimate_actual_cost_rate_per_hour": {
    "field": "estimate_line_items.actual_cost_rate_per_hour",
    "aliases": [
      "actual rate",
      "internal rate",
      "true cost rate"
    ],
    "formula": "True internal cost (e.g., $35/hr)",
    "notes": "Hidden from client. Represents true cost to RCG for labor."
  },
  "estimate_labor_cushion_amount": {
    "field": "estimate_line_items.labor_cushion_amount",
    "aliases": [
      "labor cushion",
      "labor profit",
      "hidden profit",
      "cushion amount"
    ],
    "formula": "(billing_rate - actual_cost_rate) × labor_hours",
    "notes": "Hidden profit opportunity built into labor billing. (billing_rate - actual_cost_rate) × hours."
  },
  "estimate_total_labor_cushion": {
    "field": "calculateTotalLaborCushionAmount()",
    "aliases": [
      "total cushion",
      "labor opportunity",
      "hidden profit total"
    ],
    "formula": "SUM(labor_cushion_amount) for all labor items",
    "notes": "Total hidden profit opportunity from all labor line items."
  },
  "estimate_max_gross_profit_potential": {
    "field": "trueProfitMargin",
    "aliases": [
      "max profit",
      "true profit",
      "profit potential"
    ],
    "formula": "Gross Profit + Total Labor Cushion",
    "notes": "Maximum achievable profit if all labor cushion is captured."
  },
  "estimate_max_potential_margin_percent": {
    "field": "trueProfitPercent",
    "aliases": [
      "true margin",
      "actual margin %",
      "real margin percent"
    ],
    "formula": "(Max Gross Profit / (Total Cost - Labor Cushion)) × 100",
    "notes": "True margin based on actual costs, not billing costs. Shows what margin really is."
  },
  "estimate_true_actual_cost": {
    "field": "trueActualCost",
    "aliases": [
      "true cost",
      "actual internal cost",
      "real cost"
    ],
    "formula": "Total Cost - Total Labor Cushion",
    "notes": "What the project actually costs internally (billing costs minus cushion)."
  },
  "estimate_gross_profit": {
    "field": "calculateEstimateGrossProfit()",
    "aliases": [
      "profit",
      "markup profit",
      "gross margin amount"
    ],
    "formula": "Total Amount - Total Cost",
    "notes": "Standard visible markup profit only (excludes labor cushion)."
  },
  "estimate_gross_margin": {
    "field": "calculateEstimateGrossMargin()",
    "aliases": [
      "margin %",
      "profit margin",
      "markup percent"
    ],
    "formula": "(Gross Profit / Total Amount) × 100",
    "notes": "Margin shown to clients (excludes labor cushion)."
  },
  "estimate_average_markup": {
    "field": "calculateEstimateAverageMarkup()",
    "aliases": [
      "avg markup",
      "average profit margin"
    ],
    "formula": "AVG(line_items.markup_percent)"
  },
  "estimate_total_markup": {
    "field": "calculateEstimateTotalMarkup()",
    "aliases": [
      "total markup amount",
      "total profit amount"
    ],
    "formula": "SUM(line_items.markup_amount)"
  },
  "expense_amount": {
    "field": "expenses.amount",
    "aliases": [
      "amount",
      "cost",
      "expense cost",
      "transaction amount"
    ],
    "formula": "Direct field - transaction amount",
    "notes": "The actual dollar amount of the expense transaction."
  },
  "expense_is_split": {
    "field": "expenses.is_split",
    "aliases": [
      "split expense",
      "allocated expense"
    ],
    "formula": "Boolean - expense allocated across multiple projects",
    "notes": "When true, expense is split across multiple projects via expense_splits table."
  },
  "expense_split_amount": {
    "field": "expense_splits.split_amount",
    "aliases": [
      "allocated amount",
      "portion amount"
    ],
    "formula": "Portion allocated to specific project",
    "notes": "How much of the parent expense is allocated to this specific project."
  },
  "expense_split_percentage": {
    "field": "expense_splits.split_percentage",
    "aliases": [
      "allocation percent",
      "split %"
    ],
    "formula": "(split_amount / parent_expense.amount) × 100"
  },
  "expense_lunch_taken": {
    "field": "expenses.lunch_taken",
    "aliases": [
      "took lunch",
      "lunch break",
      "had lunch"
    ],
    "formula": "Boolean - whether lunch break was taken during shift",
    "notes": "Only applicable to labor_internal expenses (time entries)."
  },
  "expense_lunch_duration_minutes": {
    "field": "expenses.lunch_duration_minutes",
    "aliases": [
      "lunch minutes",
      "lunch duration",
      "break time"
    ],
    "formula": "Integer (15-120) - duration of lunch break in minutes",
    "notes": "Only meaningful when lunch_taken = true. Typically 30-60 minutes."
  },
  "expense_gross_hours": {
    "field": "CALCULATED: (end_time - start_time) / 3600",
    "aliases": [
      "gross hours",
      "total hours",
      "shift hours",
      "raw hours"
    ],
    "formula": "(end_time - start_time) / 3600",
    "notes": "CALCULATED FIELD - not stored in database. Total shift duration before lunch deduction. Computed from start_time/end_time in frontend (useTimeEntries.ts) and should be calculated in execute_simple_report RPC."
  },
  "expense_net_hours": {
    "field": "expenses.hours",
    "aliases": [
      "hours",
      "billable hours",
      "net hours",
      "productive hours",
      "worked hours"
    ],
    "formula": "Gross Hours - (Lunch Duration / 60) when lunch_taken = true",
    "notes": "Billable hours after lunch deduction. Stored in expenses.hours field. Amount = Net Hours × Hourly Rate."
  },
  "total_expenses_by_project": {
    "field": "calculateProjectExpenses()",
    "aliases": [
      "project expenses",
      "total project costs",
      "project spend"
    ],
    "formula": "SUM(expenses.amount) + SUM(expense_splits.split_amount)",
    "notes": "Combines direct expenses and split expense allocations for accurate project totals."
  },
  "expense_count_by_project": {
    "field": "calculateExpenseCount()",
    "aliases": [
      "expense count",
      "number of expenses"
    ],
    "formula": "COUNT(expenses) + COUNT(expense_splits)",
    "notes": "Total number of expense records for the project, including splits."
  },
  "expense_start_time": {
    "field": "expenses.start_time",
    "aliases": [
      "clock in",
      "start",
      "begin time"
    ],
    "formula": "Timestamp when time entry began",
    "notes": "Only populated for labor_internal expenses."
  },
  "expense_end_time": {
    "field": "expenses.end_time",
    "aliases": [
      "clock out",
      "end",
      "finish time"
    ],
    "formula": "Timestamp when time entry ended",
    "notes": "Only populated for labor_internal expenses."
  },
  "expense_category": {
    "field": "expenses.category",
    "aliases": [
      "category",
      "expense type",
      "type"
    ],
    "formula": "ENUM: 'labor_internal' | 'materials' | 'subcontractor' | 'equipment' | etc.",
    "notes": "Critical field for determining expense type and applicable calculations."
  },
  "expense_date": {
    "field": "expenses.expense_date",
    "aliases": [
      "work date",
      "date",
      "expense date",
      "business date"
    ],
    "formula": "Date when the work was performed or expense incurred",
    "notes": "PRIMARY DATE FOR BUSINESS QUERIES. Use this for \"last week's hours\", payroll, financial reporting. This is the business date, not when the entry was created."
  },
  "expense_created_at": {
    "field": "expenses.created_at",
    "aliases": [
      "created",
      "entry date",
      "record created"
    ],
    "formula": "Timestamp when the expense record was created in the system",
    "notes": "When the record was created in the database. NOT the same as when work was done (use expense_date for that) or when it was submitted for approval."
  },
  "expense_submitted_for_approval_at": {
    "field": "expenses.submitted_for_approval_at",
    "aliases": [
      "submitted",
      "submission date",
      "submitted at"
    ],
    "formula": "Timestamp when the expense was submitted for approval",
    "notes": "When the user clicked \"Submit for Approval\". Use for workflow metrics like \"how long has this been pending\"."
  },
  "expense_approved_at": {
    "field": "expenses.approved_at",
    "aliases": [
      "approved",
      "approval date",
      "decision date"
    ],
    "formula": "Timestamp when the expense was approved or rejected",
    "notes": "When the approval decision was made. May be null if status is still pending."
  },
  "expense_worker_name": {
    "field": "payees.payee_name",
    "aliases": [
      "worker",
      "employee",
      "employee name",
      "worker_name",
      "payee_name"
    ],
    "formula": "Employee name from payees table via JOIN on payee_id",
    "notes": "Accessed via JOIN: expenses.payee_id → payees.id. For internal workers only (is_internal=true). Aliased as worker_name in reports."
  },
  "expense_employee_number": {
    "field": "payees.employee_number",
    "aliases": [
      "employee #",
      "employee number",
      "emp number",
      "emp #"
    ],
    "formula": "Employee ID from payees table via JOIN",
    "notes": "Accessed via JOIN: expenses.payee_id → payees.id."
  },
  "expense_hourly_rate": {
    "field": "payees.hourly_rate",
    "aliases": [
      "rate",
      "hourly rate",
      "pay rate",
      "wage"
    ],
    "formula": "Employee hourly rate from payees table via JOIN",
    "notes": "Accessed via JOIN: expenses.payee_id → payees.id. Used to calculate amount = hours × rate."
  },
  "expense_approval_status": {
    "field": "expenses.approval_status",
    "aliases": [
      "status",
      "approval status",
      "approval",
      "approval_status"
    ],
    "formula": "ENUM: 'pending' | 'approved' | 'rejected'",
    "notes": "Tracks the approval state of time entries and expenses."
  },
  "expense_description": {
    "field": "expenses.description",
    "aliases": [
      "description",
      "notes",
      "details",
      "note"
    ],
    "formula": "Free-text description/notes for the expense or time entry",
    "notes": "User-entered description or notes. May contain hours for manual entries."
  },
  "expense_project_number": {
    "field": "projects.project_number",
    "aliases": [
      "project #",
      "project number",
      "proj #"
    ],
    "formula": "Project identifier from projects table via JOIN",
    "notes": "Accessed via JOIN: expenses.project_id → projects.id."
  },
  "expense_project_name": {
    "field": "projects.project_name",
    "aliases": [
      "project name",
      "project",
      "job name"
    ],
    "formula": "Project name from projects table via JOIN",
    "notes": "Accessed via JOIN: expenses.project_id → projects.id."
  },
  "expense_client_name": {
    "field": "projects.client_name",
    "aliases": [
      "client",
      "customer",
      "client name"
    ],
    "formula": "Client name from projects table via JOIN",
    "notes": "Accessed via JOIN: expenses.project_id → projects.id."
  },
  "quote_quote_amount": {
    "field": "quotes.quote_amount",
    "aliases": [
      "quote amount",
      "quoted price",
      "bid amount",
      "vendor quote"
    ],
    "formula": "Direct field - total quoted to client/vendor",
    "notes": "The base cost quoted by the vendor before any markup."
  },
  "quote_client_amount": {
    "field": "quotes.client_amount",
    "aliases": [
      "client price",
      "selling price",
      "charged amount"
    ],
    "formula": "Amount charged to client (may include markup)",
    "notes": "What the client is charged (quote_amount + markup)."
  },
  "quote_markup_amount": {
    "field": "quotes.markup_amount",
    "aliases": [
      "markup",
      "profit amount",
      "margin amount"
    ],
    "formula": "client_amount - quote_amount",
    "notes": "Profit margin added to vendor quote for client billing."
  },
  "quote_markup_percent": {
    "field": "quotes.markup_percent",
    "aliases": [
      "markup %",
      "profit margin %",
      "margin percent"
    ],
    "formula": "(markup_amount / quote_amount) × 100",
    "notes": "Markup as percentage of vendor quote cost."
  },
  "quote_profit_per_unit": {
    "field": "quotes.profit_per_unit",
    "aliases": [
      "unit profit",
      "profit per item"
    ],
    "formula": "Total profit / quantity (if applicable)",
    "notes": "Profit breakdown per unit when quantity is specified."
  },
  "quote_cost_variance_status": {
    "field": "getCostVarianceStatus()",
    "aliases": [
      "variance status",
      "cost comparison",
      "quote vs actual"
    ],
    "formula": "Compare actual vs quoted costs",
    "notes": "Status indicating if actual costs match quoted amounts."
  },
  "quote_best_quote_per_category": {
    "field": "getBestQuoteForCategory()",
    "aliases": [
      "best quote",
      "lowest bid",
      "cheapest option",
      "optimal quote"
    ],
    "formula": "Lowest quote_amount by category",
    "notes": "Automatically identifies the lowest quote for each category to help with vendor selection."
  },
  "quote_status": {
    "field": "quotes.status",
    "aliases": [
      "status",
      "quote status"
    ],
    "formula": "ENUM: 'pending' | 'accepted' | 'rejected' | 'expired'",
    "notes": "Current status of the quote in the approval process."
  },
  "quote_category": {
    "field": "quotes.category",
    "aliases": [
      "category",
      "type",
      "quote type"
    ],
    "formula": "ENUM: 'materials' | 'labor' | 'equipment' | 'subcontractor' | etc.",
    "notes": "Type of work or materials the quote covers."
  },
  "quote_vendor_name": {
    "field": "quotes.vendor_name",
    "aliases": [
      "vendor",
      "supplier",
      "company"
    ],
    "formula": "Name of the vendor providing the quote",
    "notes": "Human-readable vendor identifier."
  },
  "quote_description": {
    "field": "quotes.description",
    "aliases": [
      "description",
      "details",
      "scope"
    ],
    "formula": "Detailed description of quoted work/materials",
    "notes": "Detailed explanation of what the quote covers."
  },
  "quote_valid_until": {
    "field": "quotes.valid_until",
    "aliases": [
      "expiration",
      "expires",
      "valid date"
    ],
    "formula": "Date until which the quote remains valid",
    "notes": "Quotes may expire and require re-quoting."
  },
  "revenue_invoice_amount": {
    "field": "project_revenues.amount",
    "aliases": [
      "invoice amount",
      "revenue amount",
      "billed amount",
      "amount"
    ],
    "formula": "Direct DB field - individual invoice amount",
    "notes": "The dollar amount of a specific invoice/revenue entry."
  },
  "revenue_invoice_date": {
    "field": "project_revenues.invoice_date",
    "aliases": [
      "invoice date",
      "billed date",
      "date",
      "issued date"
    ],
    "formula": "Direct DB field - when invoice was issued",
    "notes": "Date the invoice was created/issued to the client."
  },
  "revenue_invoice_number": {
    "field": "project_revenues.invoice_number",
    "aliases": [
      "invoice number",
      "invoice #",
      "reference number",
      "invoice ref"
    ],
    "formula": "Direct DB field - QuickBooks invoice reference",
    "notes": "Unique identifier from QuickBooks or internal system."
  },
  "revenue_total_invoiced": {
    "field": "reporting.project_financials.total_invoiced",
    "aliases": [
      "total invoiced",
      "total revenue",
      "invoiced total",
      "revenue received"
    ],
    "formula": "SUM(project_revenues.amount) for direct + SUM(revenue_splits.split_amount) for splits",
    "notes": "Total revenue actually received. Handles split revenues correctly via the view."
  },
  "revenue_invoice_count": {
    "field": "reporting.project_financials.invoice_count",
    "aliases": [
      "invoice count",
      "number of invoices",
      "billing count"
    ],
    "formula": "COUNT(project_revenues) + COUNT(revenue_splits)",
    "notes": "Total number of invoice/revenue records for the project."
  },
  "revenue_revenue_variance": {
    "field": "reporting.project_financials.revenue_variance",
    "aliases": [
      "billing gap",
      "remaining to bill",
      "unbilled amount",
      "revenue gap"
    ],
    "formula": "contracted_amount - total_invoiced",
    "notes": "How much is left to bill. Positive = still owed, Negative = overbilled."
  },
  "revenue_revenue_variance_percent": {
    "field": "reporting.project_financials.revenue_variance_percent",
    "aliases": [
      "billing gap %",
      "revenue variance %"
    ],
    "formula": "(revenue_variance / contracted_amount) × 100",
    "notes": "Revenue variance as percentage of contract value."
  },
  "revenue_split_amount": {
    "field": "revenue_splits.split_amount",
    "aliases": [
      "split amount",
      "allocated revenue",
      "revenue portion"
    ],
    "formula": "Direct DB field - portion allocated to specific project",
    "notes": "Only exists when parent revenue.is_split = true."
  },
  "revenue_split_percentage": {
    "field": "revenue_splits.split_percentage",
    "aliases": [
      "split %",
      "allocation percent",
      "revenue split %"
    ],
    "formula": "(split_amount / parent_revenue.amount) × 100",
    "notes": "Calculated field for display purposes showing allocation percentage."
  },
  "revenue_is_split": {
    "field": "project_revenues.is_split",
    "aliases": [
      "split revenue",
      "allocated revenue",
      "multi-project revenue"
    ],
    "formula": "Boolean flag - true when revenue is allocated across multiple projects",
    "notes": "When true, project_id points to SYS-000 and revenue is split via revenue_splits."
  },
  "revenue_total_revenue_by_project": {
    "field": "calculateProjectRevenue()",
    "aliases": [
      "project revenue",
      "total project revenue",
      "revenue by project"
    ],
    "formula": "SUM(revenues.amount WHERE !is_split) + SUM(revenue_splits.split_amount)",
    "notes": "Combines direct and split revenues for accurate project totals."
  },
  "revenue_status": {
    "field": "project_revenues.status",
    "aliases": [
      "status",
      "payment status",
      "invoice status"
    ],
    "formula": "ENUM: 'pending' | 'sent' | 'paid' | 'overdue' | 'cancelled'",
    "notes": "Current payment/collection status of the revenue."
  },
  "revenue_payment_date": {
    "field": "project_revenues.payment_date",
    "aliases": [
      "payment date",
      "paid date",
      "received date"
    ],
    "formula": "Date when payment was received",
    "notes": "When the client actually paid the invoice."
  },
  "revenue_due_date": {
    "field": "project_revenues.due_date",
    "aliases": [
      "due date",
      "payment due",
      "deadline"
    ],
    "formula": "Date payment is due from client",
    "notes": "When payment is expected from the client."
  },
  "revenue_quickbooks_invoice_id": {
    "field": "project_revenues.quickbooks_invoice_id",
    "aliases": [
      "QB invoice ID",
      "QuickBooks ID",
      "QB reference"
    ],
    "formula": "QuickBooks internal ID for the invoice",
    "notes": "Internal QuickBooks reference for API operations."
  },
  "change_order_amount": {
    "field": "change_orders.amount",
    "aliases": [
      "CO amount",
      "change amount",
      "cost impact",
      "impact amount"
    ],
    "formula": "Direct field - CO cost impact amount",
    "notes": "The dollar impact of the change order on project costs."
  },
  "change_order_client_amount": {
    "field": "change_orders.client_amount",
    "aliases": [
      "client amount",
      "charged amount",
      "billing amount"
    ],
    "formula": "Amount charged to client for the change",
    "notes": "What the client is charged for this change order."
  },
  "change_order_cost_impact": {
    "field": "change_orders.cost_impact",
    "aliases": [
      "cost impact",
      "additional cost",
      "cost change"
    ],
    "formula": "Change to project costs (same as amount field)",
    "notes": "How much this change adds to RCG's costs."
  },
  "change_order_margin_impact": {
    "field": "change_orders.margin_impact",
    "aliases": [
      "margin impact",
      "profit impact",
      "margin change"
    ],
    "formula": "client_amount - cost_impact",
    "notes": "Profit impact of the change order (client_amount - cost_impact)."
  },
  "change_order_contingency_billed_to_client": {
    "field": "change_orders.contingency_billed_to_client",
    "aliases": [
      "contingency billed",
      "recovered contingency",
      "contingency recovery"
    ],
    "formula": "Portion of contingency recovered from client",
    "notes": "Amount of project contingency that was billed to the client as part of this change."
  },
  "change_order_includes_contingency": {
    "field": "change_orders.includes_contingency",
    "aliases": [
      "uses contingency",
      "contingency included",
      "from contingency"
    ],
    "formula": "Boolean flag indicating contingency usage",
    "notes": "Whether this change order utilizes project contingency."
  },
  "change_order_status": {
    "field": "change_orders.status",
    "aliases": [
      "CO status",
      "approval status",
      "status"
    ],
    "formula": "ENUM: 'draft' | 'submitted' | 'approved' | 'rejected' | 'cancelled'",
    "notes": "Current approval status of the change order."
  },
  "change_order_type": {
    "field": "change_orders.type",
    "aliases": [
      "CO type",
      "change type",
      "type"
    ],
    "formula": "ENUM: 'addition' | 'deduction' | 'modification' | 'time_extension'",
    "notes": "Type of change being requested."
  },
  "change_order_description": {
    "field": "change_orders.description",
    "aliases": [
      "description",
      "details",
      "explanation",
      "scope"
    ],
    "formula": "Detailed explanation of the change",
    "notes": "Human-readable description of what the change entails."
  },
  "change_order_requested_by": {
    "field": "change_orders.requested_by",
    "aliases": [
      "requester",
      "requested by",
      "initiated by"
    ],
    "formula": "User ID of person who requested the change",
    "notes": "Who initiated this change order request."
  },
  "change_order_approved_by": {
    "field": "change_orders.approved_by",
    "aliases": [
      "approver",
      "approved by",
      "authorized by"
    ],
    "formula": "User ID of person who approved the change",
    "notes": "Who approved this change order."
  },
  "change_order_approved_at": {
    "field": "change_orders.approved_at",
    "aliases": [
      "approved date",
      "approval date",
      "approved at"
    ],
    "formula": "Timestamp when change was approved",
    "notes": "When the change order was officially approved."
  },
  "change_order_submitted_at": {
    "field": "change_orders.submitted_at",
    "aliases": [
      "submitted date",
      "submission date",
      "submitted at"
    ],
    "formula": "Timestamp when change was submitted for approval",
    "notes": "When the change order was submitted for approval."
  },
  "change_order_project_impact": {
    "field": "calculateChangeOrderImpact()",
    "aliases": [
      "impact",
      "project impact",
      "effect on project"
    ],
    "formula": "Combined impact on project timeline and budget",
    "notes": "Overall assessment of how the change affects the project."
  },
  "change_order_schedule_impact_days": {
    "field": "change_orders.schedule_impact_days",
    "aliases": [
      "schedule impact",
      "timeline impact",
      "days added"
    ],
    "formula": "Number of days added to project timeline",
    "notes": "How many days this change adds to the project duration."
  },
  "work_order_count": {
    "field": "statistics.total",
    "aliases": [
      "total work orders",
      "WO count",
      "number of work orders"
    ],
    "formula": "COUNT(projects WHERE project_type = 'work_order')",
    "notes": "Total number of work orders across all projects."
  },
  "work_order_pending_in_progress": {
    "field": "statistics.pendingInProgress",
    "aliases": [
      "active work orders",
      "in progress WOs",
      "current work orders"
    ],
    "formula": "COUNT(WOs WHERE status IN ('in_progress', 'estimating'))",
    "notes": "Work orders currently being worked on or in process."
  },
  "work_order_completed_this_week": {
    "field": "statistics.completedThisWeek",
    "aliases": [
      "weekly completions",
      "this week completions"
    ],
    "formula": "COUNT(WOs WHERE status = 'complete' AND end_date >= weekStart)",
    "notes": "Work orders completed in the current week."
  },
  "work_order_completed_this_month": {
    "field": "statistics.completedThisMonth",
    "aliases": [
      "monthly completions",
      "this month completions"
    ],
    "formula": "COUNT(WOs WHERE status = 'complete' AND end_date >= monthStart)",
    "notes": "Work orders completed in the current month."
  },
  "work_order_has_real_estimate": {
    "field": "has_estimate && !is_auto_generated_estimate",
    "aliases": [
      "real estimate",
      "valid estimate",
      "proper estimate"
    ],
    "formula": "Excludes system-created placeholder estimates",
    "notes": "Whether the work order has a real estimate (not auto-generated placeholder)."
  },
  "work_order_total_expenses": {
    "field": "workOrder.total_expenses",
    "aliases": [
      "WO expenses",
      "work order costs",
      "total costs"
    ],
    "formula": "SUM(expenses.amount WHERE project_id = WO)",
    "notes": "All expenses incurred on this work order."
  },
  "work_order_expense_count": {
    "field": "workOrder.expense_count",
    "aliases": [
      "expense count",
      "number of expenses"
    ],
    "formula": "COUNT(expenses WHERE project_id = WO)",
    "notes": "Number of expense transactions for this work order."
  },
  "work_order_dne_utilization_percent": {
    "field": "calculateDNEUtilization()",
    "aliases": [
      "budget utilization",
      "DNE %",
      "budget used %"
    ],
    "formula": "(Total Expenses / Do Not Exceed) × 100",
    "notes": "Percentage of budget cap that has been used."
  },
  "work_order_number": {
    "field": "generateWorkOrderNumber()",
    "aliases": [
      "WO number",
      "work order #",
      "WO ID"
    ],
    "formula": "{project_number}-WO-{counter}",
    "notes": "Unique identifier for work orders under a project."
  },
  "work_order_do_not_exceed": {
    "field": "projects.do_not_exceed",
    "aliases": [
      "DNE",
      "budget cap",
      "max budget",
      "WO limit"
    ],
    "formula": "Maximum billable amount (work orders only)",
    "notes": "CRITICAL: Budget cap for work orders. Expenses should not exceed this amount."
  },
  "work_order_customer_po_number": {
    "field": "projects.customer_po_number",
    "aliases": [
      "PO number",
      "customer PO",
      "client PO"
    ],
    "formula": "Client reference number",
    "notes": "Purchase order number provided by the client."
  },
  "work_order_counter": {
    "field": "projects.work_order_counter",
    "aliases": [
      "WO counter",
      "counter",
      "sequence"
    ],
    "formula": "Auto-incrementing per project",
    "notes": "Sequential counter for work orders under each project."
  },
  "work_order_original_est_costs": {
    "field": "projects.original_est_costs",
    "aliases": [
      "original estimate",
      "baseline costs",
      "initial costs"
    ],
    "formula": "Initial cost estimate at work order creation",
    "notes": "Immutable baseline cost estimate set when work order was created."
  },
  "work_order_adjusted_est_costs": {
    "field": "projects.adjusted_est_costs",
    "aliases": [
      "current estimate",
      "adjusted costs",
      "revised costs"
    ],
    "formula": "Original Est. Costs + Change Order Costs",
    "notes": "Current expected costs including approved changes."
  },
  "work_order_projected_margin": {
    "field": "projects.projected_margin",
    "aliases": [
      "projected margin",
      "expected margin",
      "forecast margin"
    ],
    "formula": "contracted_amount - adjusted_est_costs",
    "notes": "Expected final margin based on current estimates."
  },
  "work_order_contracted_amount": {
    "field": "projects.contracted_amount",
    "aliases": [
      "contract amount",
      "agreed amount",
      "WO value"
    ],
    "formula": "Total contract value with client",
    "notes": "What the client agreed to pay for this work order."
  },
  "work_order_status": {
    "field": "projects.status",
    "aliases": [
      "status",
      "WO status"
    ],
    "formula": "ENUM: 'estimating' | 'approved' | 'in_progress' | 'complete'",
    "notes": "Current status of the work order in the process."
  },
  "work_order_project_type": {
    "field": "projects.project_type",
    "aliases": [
      "type",
      "project type"
    ],
    "formula": "'work_order' (constant for work orders)",
    "notes": "Always \"work_order\" for work order records."
  },
  "work_order_category": {
    "field": "projects.category",
    "aliases": [
      "category",
      "WO category"
    ],
    "formula": "'construction' | 'system' | 'overhead'",
    "notes": "Controls which work orders are visible in different contexts."
  },
  "work_order_start_date": {
    "field": "projects.start_date",
    "aliases": [
      "start",
      "began",
      "started"
    ],
    "formula": "When work order work began",
    "notes": "Actual start date of work order execution."
  },
  "work_order_end_date": {
    "field": "projects.end_date",
    "aliases": [
      "end",
      "completed",
      "finished"
    ],
    "formula": "When work order was completed",
    "notes": "Date when work order reached completion status."
  },
  "work_order_created_at": {
    "field": "projects.created_at",
    "aliases": [
      "created",
      "creation date"
    ],
    "formula": "When work order was first created",
    "notes": "Timestamp of work order creation in the system."
  },
  "weekly_labor_employee_name": {
    "field": "weekly_labor_hours.employee_name",
    "aliases": [
      "employee",
      "worker",
      "employee_name"
    ],
    "formula": "Derived from payees.payee_name via time entry aggregation",
    "notes": "Employee name aggregated from time entries for the week."
  },
  "weekly_labor_employee_number": {
    "field": "weekly_labor_hours.employee_number",
    "aliases": [
      "employee #",
      "emp number"
    ],
    "formula": "Derived from payees.employee_number"
  },
  "weekly_labor_week_start": {
    "field": "weekly_labor_hours.week_start_sunday",
    "aliases": [
      "week start",
      "week starting",
      "week_start_sunday"
    ],
    "formula": "DATE_TRUNC(week, expense_date) adjusted to Sunday start",
    "notes": "First day of the week (Sunday) for the aggregated data."
  },
  "weekly_labor_week_end": {
    "field": "weekly_labor_hours.week_end_saturday",
    "aliases": [
      "week end",
      "week ending",
      "week_end_saturday"
    ],
    "formula": "week_start_sunday + 6 days",
    "notes": "Last day of the week (Saturday)."
  },
  "weekly_labor_total_hours": {
    "field": "weekly_labor_hours.total_hours",
    "aliases": [
      "total hours",
      "weekly hours",
      "hours"
    ],
    "formula": "SUM(expenses.hours) for the week",
    "notes": "Total net billable hours for the week (after lunch deductions)."
  },
  "weekly_labor_gross_hours": {
    "field": "weekly_labor_hours.gross_hours",
    "aliases": [
      "gross hours",
      "shift hours"
    ],
    "formula": "SUM(calculated gross hours) for the week",
    "notes": "Total gross shift hours for the week (before lunch deductions). VERIFY THIS COLUMN EXISTS IN VIEW."
  },
  "weekly_labor_total_cost": {
    "field": "weekly_labor_hours.total_cost",
    "aliases": [
      "total cost",
      "weekly cost",
      "labor cost"
    ],
    "formula": "SUM(expenses.amount) for the week",
    "notes": "Total labor cost for the week."
  },
  "weekly_labor_hourly_rate": {
    "field": "weekly_labor_hours.hourly_rate",
    "aliases": [
      "rate",
      "hourly rate"
    ],
    "formula": "From payees.hourly_rate or calculated average"
  },
  "weekly_labor_entry_count": {
    "field": "weekly_labor_hours.entry_count",
    "aliases": [
      "entries",
      "entry count"
    ],
    "formula": "COUNT(expenses) for the week",
    "notes": "Number of time entries in the week."
  },
  "weekly_labor_approved_entries": {
    "field": "weekly_labor_hours.approved_entries",
    "aliases": [
      "approved",
      "approved count"
    ],
    "formula": "COUNT(expenses WHERE approval_status='approved')"
  },
  "weekly_labor_pending_entries": {
    "field": "weekly_labor_hours.pending_entries",
    "aliases": [
      "pending",
      "pending count"
    ],
    "formula": "COUNT(expenses WHERE approval_status='pending')"
  },
  "weekly_labor_rejected_entries": {
    "field": "weekly_labor_hours.rejected_entries",
    "aliases": [
      "rejected",
      "rejected count"
    ],
    "formula": "COUNT(expenses WHERE approval_status='rejected')"
  },
  "training_employee_name": {
    "field": "reporting.training_status.employee_name",
    "aliases": [
      "employee",
      "trainee"
    ],
    "formula": "From payees.payee_name via training assignment"
  },
  "training_content_title": {
    "field": "reporting.training_status.content_title",
    "aliases": [
      "title",
      "training title",
      "content"
    ],
    "formula": "From training_content.title"
  },
  "training_content_type": {
    "field": "reporting.training_status.content_type",
    "aliases": [
      "type",
      "format"
    ],
    "formula": "ENUM: 'video_link' | 'video_embed' | 'document' | 'presentation' | 'external_link'"
  },
  "training_status": {
    "field": "reporting.training_status.status",
    "aliases": [
      "status",
      "completion status"
    ],
    "formula": "CALCULATED: 'completed' | 'overdue' | 'assigned' | 'pending'"
  },
  "training_is_required": {
    "field": "reporting.training_status.is_required",
    "aliases": [
      "required",
      "mandatory"
    ],
    "formula": "Boolean - whether training is mandatory"
  },
  "training_due_date": {
    "field": "reporting.training_status.due_date",
    "aliases": [
      "due",
      "deadline"
    ],
    "formula": "Date training must be completed by"
  },
  "training_days_remaining": {
    "field": "reporting.training_status.days_remaining",
    "aliases": [
      "remaining",
      "days left"
    ],
    "formula": "due_date - CURRENT_DATE",
    "notes": "Negative values indicate overdue."
  },
  "training_assigned_at": {
    "field": "reporting.training_status.assigned_at",
    "aliases": [
      "assigned",
      "assignment date"
    ],
    "formula": "Timestamp when training was assigned"
  },
  "training_completed_at": {
    "field": "reporting.training_status.completed_at",
    "aliases": [
      "completed",
      "completion date"
    ],
    "formula": "Timestamp when training was completed"
  },
  "time_entry_id": {
    "field": "expenses.id",
    "aliases": [],
    "formula": "UUID primary key",
    "notes": "Unique identifier for the time entry record."
  },
  "worker_name": {
    "field": "payees.payee_name",
    "aliases": [
      "employee",
      "worker",
      "employee_name",
      "name",
      "staff"
    ],
    "formula": "Joined from payees table via expenses.payee_id",
    "notes": "Employee name from payees table. Use payee_name in SQL joins."
  },
  "employee_number": {
    "field": "payees.employee_number",
    "aliases": [
      "emp #",
      "employee #",
      "emp number",
      "staff number"
    ],
    "formula": "Joined from payees table via expenses.payee_id",
    "notes": "Employee ID number from payees table."
  },
  "time_entry_expense_date": {
    "field": "expenses.expense_date",
    "aliases": [
      "work date",
      "date",
      "shift date"
    ],
    "formula": "Date when work was performed",
    "notes": "Business date for the time entry. Used for payroll periods."
  },
  "time_entry_start_time": {
    "field": "expenses.start_time",
    "aliases": [
      "clock in",
      "start",
      "in time"
    ],
    "formula": "Timestamp when shift began",
    "notes": "Clock-in time. Used with end_time to calculate gross_hours."
  },
  "time_entry_end_time": {
    "field": "expenses.end_time",
    "aliases": [
      "clock out",
      "end",
      "out time"
    ],
    "formula": "Timestamp when shift ended",
    "notes": "Clock-out time. Used with start_time to calculate gross_hours."
  },
  "time_entry_created_at": {
    "field": "expenses.created_at",
    "aliases": [],
    "formula": "Timestamp when record was created",
    "notes": "When the time entry was first created in the system."
  },
  "time_entry_submitted_at": {
    "field": "expenses.submitted_for_approval_at",
    "aliases": [
      "submitted",
      "submission date"
    ],
    "formula": "Timestamp when submitted for approval",
    "notes": "When the entry was submitted for manager approval. NULL if not yet submitted."
  },
  "time_entry_approved_at": {
    "field": "expenses.approved_at",
    "aliases": [
      "approved",
      "approval date"
    ],
    "formula": "Timestamp when approved or rejected",
    "notes": "When the entry was approved or rejected. NULL if still pending."
  },
  "time_entry_gross_hours": {
    "field": "CALCULATED: (end_time - start_time) / 3600",
    "aliases": [
      "gross hours",
      "total hours",
      "shift hours",
      "raw hours",
      "total time"
    ],
    "formula": "EXTRACT(EPOCH FROM (end_time - start_time)) / 3600",
    "notes": "CALCULATED FIELD - total shift duration before lunch deduction. Computed from start_time/end_time. For compliance tracking (e.g., >8 hours may indicate OT eligibility)."
  },
  "time_entry_hours": {
    "field": "expenses.hours",
    "aliases": [
      "hours",
      "billable hours",
      "net hours",
      "productive hours",
      "worked hours",
      "payable hours"
    ],
    "formula": "Gross Hours - (lunch_duration_minutes / 60) when lunch_taken = true",
    "notes": "Stored billable hours after lunch deduction. Used for: amount = hours × hourly_rate."
  },
  "time_entry_lunch_taken": {
    "field": "expenses.lunch_taken",
    "aliases": [
      "took lunch",
      "lunch break",
      "had lunch"
    ],
    "formula": "Boolean - whether lunch break was taken during shift",
    "notes": "Indicates if worker took a lunch break. Required for compliance in some jurisdictions."
  },
  "time_entry_lunch_duration_minutes": {
    "field": "expenses.lunch_duration_minutes",
    "aliases": [
      "lunch minutes",
      "lunch duration",
      "break time",
      "lunch length"
    ],
    "formula": "Integer 15-120 - minutes of lunch break",
    "notes": "Length of lunch break in minutes. Typically 30-60. Only meaningful when lunch_taken = true."
  },
  "time_entry_hourly_rate": {
    "field": "payees.hourly_rate",
    "aliases": [
      "rate",
      "pay rate",
      "hourly pay"
    ],
    "formula": "Joined from payees table via expenses.payee_id",
    "notes": "Employee hourly rate from payees table. Used to calculate amount."
  },
  "time_entry_amount": {
    "field": "expenses.amount",
    "aliases": [
      "amount",
      "cost",
      "total cost",
      "labor cost"
    ],
    "formula": "hours × hourly_rate",
    "notes": "Total labor cost for this time entry. Calculated as net hours × hourly rate."
  },
  "time_entry_project_id": {
    "field": "expenses.project_id",
    "aliases": [],
    "formula": "Foreign key to projects table",
    "notes": "Project this time entry is charged to."
  },
  "time_entry_project_number": {
    "field": "projects.project_number",
    "aliases": [
      "project #",
      "job number"
    ],
    "formula": "Joined from projects table",
    "notes": "Project number for display."
  },
  "time_entry_project_name": {
    "field": "projects.project_name",
    "aliases": [
      "project",
      "job name"
    ],
    "formula": "Joined from projects table",
    "notes": "Project name for display."
  },
  "time_entry_client_name": {
    "field": "projects.client_name",
    "aliases": [
      "client",
      "customer"
    ],
    "formula": "Joined from projects table",
    "notes": "Client name from project."
  },
  "time_entry_approval_status": {
    "field": "expenses.approval_status",
    "aliases": [
      "status",
      "approval",
      "approved"
    ],
    "formula": "Enum: pending | approved | rejected",
    "notes": "Current approval state of the time entry. Values: pending, approved, rejected."
  },
  "time_entry_description": {
    "field": "expenses.description",
    "aliases": [
      "notes",
      "work description",
      "details"
    ],
    "formula": "Free text description",
    "notes": "Work description or notes for the time entry."
  },
  "payee_id": {
    "field": "payees.id",
    "aliases": [],
    "formula": "UUID primary key",
    "notes": "Unique identifier for the payee record."
  },
  "payee_name": {
    "field": "payees.payee_name",
    "aliases": [
      "vendor",
      "subcontractor",
      "employee",
      "worker",
      "supplier",
      "name"
    ],
    "formula": "Business or individual name",
    "notes": "Display name for the vendor, subcontractor, or employee."
  },
  "payee_type": {
    "field": "payees.payee_type",
    "aliases": [
      "type"
    ],
    "formula": "Enum: vendor | subcontractor | employee",
    "notes": "Type of payee. Vendors = material suppliers, Subcontractors = trade contractors."
  },
  "payee_is_internal": {
    "field": "payees.is_internal",
    "aliases": [
      "internal",
      "employee",
      "is employee"
    ],
    "formula": "Boolean - true for company employees",
    "notes": "True for company employees who log time. False for external vendors/subcontractors."
  },
  "payee_employee_number": {
    "field": "payees.employee_number",
    "aliases": [
      "emp #",
      "employee #",
      "emp number",
      "staff number",
      "badge number"
    ],
    "formula": "Company-assigned employee ID",
    "notes": "Internal employee ID number. Only populated for is_internal = true."
  },
  "payee_hourly_rate": {
    "field": "payees.hourly_rate",
    "aliases": [
      "rate",
      "pay rate",
      "hourly pay",
      "wage"
    ],
    "formula": "Decimal - employee pay rate",
    "notes": "Hourly pay rate for internal employees. Used to calculate time entry amounts."
  },
  "payee_job_title": {
    "field": "payees.job_title",
    "aliases": [
      "title",
      "position",
      "role"
    ],
    "formula": "Employee position/role",
    "notes": "Job title or role for internal employees."
  },
  "payee_email": {
    "field": "payees.email",
    "aliases": [
      "email address"
    ],
    "formula": "Contact email address",
    "notes": "Primary email address for the payee."
  },
  "payee_phone": {
    "field": "payees.phone",
    "aliases": [
      "phone number",
      "cell",
      "mobile"
    ],
    "formula": "Contact phone number",
    "notes": "Primary phone number for the payee."
  },
  "payee_address": {
    "field": "payees.address",
    "aliases": [],
    "formula": "Street address",
    "notes": "Physical address for the payee."
  },
  "payee_city": {
    "field": "payees.city",
    "aliases": [],
    "formula": "City name"
  },
  "payee_state": {
    "field": "payees.state",
    "aliases": [],
    "formula": "State/province code"
  },
  "payee_zip": {
    "field": "payees.zip",
    "aliases": [
      "zip",
      "postal code"
    ],
    "formula": "Postal code"
  },
  "payee_quickbooks_vendor_id": {
    "field": "payees.quickbooks_vendor_id",
    "aliases": [
      "qb id",
      "quickbooks id"
    ],
    "formula": "External ID from QuickBooks",
    "notes": "QuickBooks vendor/employee ID for sync purposes."
  },
  "payee_account_number": {
    "field": "payees.account_number",
    "aliases": [
      "account #",
      "acct number"
    ],
    "formula": "Vendor account number",
    "notes": "Customer/vendor account number with this payee."
  },
  "payee_status": {
    "field": "payees.status",
    "aliases": [
      "status",
      "active"
    ],
    "formula": "Enum: active | inactive",
    "notes": "Active/inactive status for the payee."
  },
  "payee_created_at": {
    "field": "payees.created_at",
    "aliases": [],
    "formula": "Timestamp when record created"
  },
  "payee_updated_at": {
    "field": "payees.updated_at",
    "aliases": [],
    "formula": "Timestamp when record last updated"
  },
  "payee_vendor_type": {
    "field": "payees.vendor_type",
    "aliases": [
      "specialty",
      "trade"
    ],
    "formula": "Categorization of vendor specialty",
    "notes": "Type of materials or services the vendor provides."
  },
  "payee_tax_id": {
    "field": "payees.tax_id",
    "aliases": [
      "ein",
      "ssn",
      "tax number"
    ],
    "formula": "EIN or SSN for 1099 reporting",
    "notes": "Federal tax ID for vendors/subcontractors. Sensitive field."
  },
  "payee_total_expenses": {
    "field": "SUM(expenses.amount) WHERE payee_id = payee.id",
    "aliases": [
      "total paid",
      "spend"
    ],
    "formula": "Sum of all expenses paid to this payee",
    "notes": "Total amount paid to this vendor/subcontractor/employee across all projects."
  },
  "payee_expense_count": {
    "field": "COUNT(expenses) WHERE payee_id = payee.id",
    "aliases": [],
    "formula": "Number of expense records for this payee",
    "notes": "Total number of transactions with this payee."
  },
  "payee_quote_count": {
    "field": "COUNT(quotes) WHERE payee_id = payee.id",
    "aliases": [],
    "formula": "Number of quotes received from this payee",
    "notes": "Number of quotes submitted by this vendor."
  },
  "payee_accepted_quote_count": {
    "field": "COUNT(quotes) WHERE payee_id = payee.id AND status = 'accepted'",
    "aliases": [],
    "formula": "Number of accepted quotes from this payee",
    "notes": "How many quotes from this vendor were accepted."
  },
  "deprecated_current_margin": {
    "field": "projects.current_margin",
    "aliases": [
      "margin",
      "current margin"
    ],
    "formula": "contracted_amount - total_expenses",
    "notes": "DEPRECATED as of v2.0.0.\n\nPROBLEM: This field mixed concepts. It represented \"unrealized margin\" (contract minus actual expenses)\nwhich is neither actual profit (invoiced - expenses) nor projected profit (contract - estimated costs).\n\nREPLACEMENT: Use actual_margin instead.\n- actual_margin = total_invoiced - total_expenses (real profit)\n\nMIGRATION: \n1. Replace all references to current_margin with actual_margin\n2. Update queries to use actual_margin from reporting.project_financials view\n3. The database column will be retained during transition but will be removed in a future release\n\nWHY DEPRECATED:\n- Confusing name: \"current\" could mean many things\n- Mixed concepts: Used contract value (future) with actual expenses (past)\n- Misleading: Didn't reflect real profit (which should be invoiced - expenses)"
  },
  "deprecated_projected_margin": {
    "field": "projects.projected_margin",
    "aliases": [
      "projected margin",
      "forecast margin"
    ],
    "formula": "contracted_amount - adjusted_est_costs",
    "notes": "DEPRECATED as of v2.0.0.\n\nRENAMED TO: adjusted_est_margin\n\nREASON: \"Projected\" was ambiguous. The new name \"adjusted_est_margin\" clearly indicates:\n- \"adjusted\" = includes quote adjustments and change orders\n- \"est\" = estimated (not actual)\n- \"margin\" = profit metric\n\nMIGRATION:\n1. Replace all references to projected_margin with adjusted_est_margin\n2. Both columns exist during transition period\n3. Database triggers update both columns simultaneously\n4. projected_margin column will be removed in a future release\n\nNO BEHAVIORAL CHANGE: The calculation remains exactly the same:\nadjusted_est_margin = contracted_amount - adjusted_est_costs"
  },
  "deprecated_project_budget": {
    "field": "projects.budget",
    "aliases": [
      "budget",
      "old budget"
    ],
    "formula": "Replaced by contracted_amount",
    "notes": "DEPRECATED - Legacy field from early versions.\n\nREPLACEMENT: Use contracted_amount instead.\n\nThe \"budget\" field was ambiguous - it wasn't clear if it meant:\n- What we expect to spend (costs)\n- What the client will pay (revenue)\n\ncontracted_amount clearly indicates client-side revenue.\nadjusted_est_costs clearly indicates our expected costs."
  },
  "deprecated_estimate_rate": {
    "field": "estimate_line_items.rate",
    "aliases": [
      "rate",
      "old rate",
      "line rate"
    ],
    "formula": "Replaced by price_per_unit",
    "notes": "DEPRECATED - Legacy field renamed for clarity.\n\nREPLACEMENT: Use price_per_unit instead.\n\n\"Rate\" was ambiguous. Could mean:\n- Hourly rate\n- Unit price\n- Cost rate\n\nNew fields are explicit:\n- price_per_unit = what we charge client (revenue)\n- cost_per_unit = what we pay vendor (cost)"
  },
  "deprecated_old_revenue_calculations": {
    "field": "Various legacy fields",
    "aliases": [
      "old revenue",
      "legacy revenue",
      "old invoicing"
    ],
    "formula": "See project_revenues table",
    "notes": "DEPRECATED - Revenue tracking restructured.\n\nREPLACEMENT: Use total_invoiced from reporting.project_financials view.\n\nLegacy approach had revenue scattered across multiple fields.\nNew approach uses dedicated tables:\n- project_revenues: Direct invoices\n- revenue_splits: Split invoices across projects\n\nThe reporting view handles split calculations automatically."
  },
  "deprecated_old_expense_tracking": {
    "field": "Legacy expense fields",
    "aliases": [
      "old expenses",
      "legacy expenses"
    ],
    "formula": "See expenses table",
    "notes": "DEPRECATED - Expense tracking restructured.\n\nREPLACEMENT: Use total_expenses from reporting.project_financials view.\n\nLegacy approach didn't handle split expenses properly.\nNew approach uses:\n- expenses table: Direct expenses\n- expense_splits table: Split expenses across projects\n\nThe reporting view handles split calculations automatically."
  },
  "deprecated_old_quote_system": {
    "field": "Legacy quote fields",
    "aliases": [
      "old quotes",
      "legacy quotes"
    ],
    "formula": "See quotes table",
    "notes": "DEPRECATED - Quote system restructured.\n\nQuote system moved to dedicated tables:\n- quotes: Quote header\n- quote_line_items: Quote details with estimate line item linking\n\nQuotes now properly link to estimate line items via estimate_line_item_id,\nallowing accurate cost replacement in adjusted_est_costs calculation."
  },
  "deprecated_old_change_order_tracking": {
    "field": "Legacy CO fields",
    "aliases": [
      "old COs",
      "legacy change orders"
    ],
    "formula": "See change_orders table",
    "notes": "DEPRECATED - Change order tracking restructured.\n\nNow uses dedicated change_orders table with:\n- client_amount: Revenue impact\n- cost_impact: Cost impact\n- includes_contingency: Whether uses contingency\n\nMargins automatically recalculated via triggers when COs are approved."
  },
  "deprecated_old_work_order_fields": {
    "field": "Legacy WO fields",
    "aliases": [
      "old WOs",
      "legacy work orders"
    ],
    "formula": "See projects table with project_type filtering",
    "notes": "DEPRECATED - Work orders now use regular projects table.\n\nWork orders are projects with project_type = 'work_order'.\nThey have all the same financial fields as regular projects.\nNo separate work_orders table needed."
  },
  "deprecated_projectFinancials_ts": {
    "field": "src/utils/projectFinancials.ts",
    "aliases": [
      "projectFinancials",
      "calculateProjectFinancials"
    ],
    "formula": "Various frontend calculations",
    "notes": "DEPRECATED - The entire projectFinancials.ts file is deprecated.\n\nPROBLEM: This file duplicated database calculations in the frontend, leading to:\n- Inconsistent results\n- Maintenance burden\n- Potential drift between frontend and database values\n\nREPLACEMENT: Use database fields directly:\n- project.contracted_amount (not calculated in frontend)\n- project.adjusted_est_margin (not projectedMargin calculation)\n- project.actual_margin (not currentMargin calculation)\n- project.adjusted_est_costs (not projectedCosts calculation)\n\nMIGRATION:\n1. Replace calculateProjectFinancials() with direct DB queries\n2. Replace calculateMultipleProjectFinancials() with direct DB queries\n3. Use reporting.project_financials view for complex aggregations\n4. Move file to src/utils/deprecated/ for reference"
  }
},

  // Disambiguation guide for commonly confused terms
  disambiguationGuide: [
  "MARGIN DISAMBIGUATION:",
  "- \"profit\", \"real profit\", \"actual profit\" → actual_margin (total_invoiced - total_expenses)",
  "- \"margin\", \"expected margin\", \"projected margin\", \"forecast\" → adjusted_est_margin (contracted_amount - adjusted_est_costs)",
  "- \"original margin\", \"baseline\" → original_margin (contracted_amount - original_est_costs)",
  "",
  "DATE FIELD DISAMBIGUATION:",
  "- \"when did they work\", \"work date\", \"last week hours\" → expense_date (business date)",
  "- \"when was this entered\", \"record created\" → created_at (audit timestamp)",
  "- \"when submitted\", \"pending duration\" → submitted_for_approval_at",
  "- \"when approved\", \"approval date\" → approved_at",
  "",
  "HOURS DISAMBIGUATION:",
  "- \"hours worked\", \"billable hours\" → net hours (gross - lunch)",
  "- \"shift length\", \"total time\", \"overtime check\" → gross hours (end_time - start_time)",
  "",
  "REVENUE DISAMBIGUATION:",
  "- \"revenue\", \"billed\", \"collected\" → total_invoiced (actual received)",
  "- \"contract value\", \"deal size\" → contracted_amount (expected)",
  "- \"remaining to bill\", \"unbilled\" → revenue_variance (contracted - invoiced)"
],

  // Critical business rules the AI must follow
  criticalRules: [
  "Use `reporting.project_financials` view for project financial queries instead of raw `projects` table",
  "NEVER use the receipts table for financial calculations - receipts are documentation only",
  "Time entries are stored in the `expenses` table with category = 'labor_internal'",
  "Always filter projects by category = 'construction' unless user specifically asks for overhead or system projects",
  "To find employees, use payees table WHERE is_internal = true",
  "Vendors are material suppliers (payee_type='vendor'). Subcontractors are trade contractors (payee_type='subcontractor').",
  "Cost = what RCG pays to vendors/workers. Price = what clients are charged.",
  "actual_margin = invoiced - expenses (REAL profit). current_margin = contracted - expenses (EXPECTED profit).",
  "Use pre-calculated fields from the reporting view or projects table instead of recalculating in queries. Prefer reporting.project_financials for multi-project queries; projects table is OK for single project lookups.",
  "The view `project_financial_summary` is deprecated. Use `reporting.project_financials` instead.",
  "All vendors, subcontractors, and employees are in the `payees` table. There is no separate vendors or employees table.",
  "Use ILIKE with wildcards for name searches. Names may have variations (John vs John Smith vs J. Smith).",
  "The reporting.project_financials view handles expense and revenue splits correctly. Do not try to manually aggregate.",
  "When querying estimates for financial data, filter by status = 'approved' AND is_current_version = true",
  "Only SELECT queries are allowed. No INSERT, UPDATE, DELETE, DROP, or DDL statements."
],

  // Few-shot examples for query generation
  fewShotExamples: [
  {
    "question": "What's our total profit this month?",
    "reasoning": "User wants actual realized profit. Use actual_margin (invoiced - expenses) from the reporting view. Filter to current month and construction projects only.",
    "sql": "SELECT\n  SUM(actual_margin) as total_profit,\n  COUNT(*) as project_count\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND start_date >= DATE_TRUNC('month', CURRENT_DATE)"
  },
  {
    "question": "How much have we spent on materials this year?",
    "reasoning": "Looking for expense totals by category. Use expenses table filtered to materials category and current year.",
    "sql": "SELECT\n  SUM(e.amount) as total_materials,\n  COUNT(*) as expense_count\nFROM expenses e\nWHERE e.category = 'materials'\n  AND e.expense_date >= DATE_TRUNC('year', CURRENT_DATE)"
  },
  {
    "question": "What's our average margin percentage across all active projects?",
    "reasoning": "Need margin_percentage from projects that are in progress. Use the reporting view.",
    "sql": "SELECT\n  AVG(margin_percentage) as avg_margin_percent,\n  MIN(margin_percentage) as min_margin,\n  MAX(margin_percentage) as max_margin,\n  COUNT(*) as project_count\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status IN ('in_progress', 'approved')"
  },
  {
    "question": "Show me projects over budget",
    "reasoning": "Over budget means cost_variance > 0. Use the reporting view which calculates this.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  cost_variance,\n  cost_variance_percent,\n  budget_utilization_percent\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND cost_variance > 0\nORDER BY cost_variance DESC"
  },
  {
    "question": "Which projects have low margins?",
    "reasoning": "Low margin typically means below 15-20%. Filter by margin_percentage.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  current_margin,\n  margin_percentage,\n  status\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND margin_percentage < 15\n  AND status NOT IN ('cancelled', 'on_hold')\nORDER BY margin_percentage ASC"
  },
  {
    "question": "Find projects with remaining contingency",
    "reasoning": "Check contingency_remaining > 0 for available buffer.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  contingency_amount,\n  contingency_used,\n  contingency_remaining\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND contingency_remaining > 0\nORDER BY contingency_remaining DESC"
  },
  {
    "question": "How many hours did John work last week?",
    "reasoning": "Time entries are in expenses table with category='labor_internal'. Calculate hours from start_time/end_time minus lunch. Use ILIKE for fuzzy name matching. Join to payees for employee info.",
    "sql": "SELECT\n  p.payee_name,\n  SUM(\n    CASE\n      WHEN e.lunch_taken = true THEN\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600) - (e.lunch_duration_minutes / 60.0)\n      ELSE\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600)\n    END\n  ) as total_hours,\n  SUM(e.amount) as total_billed\nFROM expenses e\nJOIN payees p ON e.payee_id = p.id\nWHERE p.is_internal = true\n  AND p.payee_name ILIKE '%john%'\n  AND e.category = 'labor_internal'\n  AND e.expense_date >= CURRENT_DATE - INTERVAL '7 days'\nGROUP BY p.payee_name"
  },
  {
    "question": "Show me all employee hours this month by person",
    "reasoning": "Aggregate time entries by employee. Calculate net billable hours from start_time/end_time minus lunch. Filter to internal payees only.",
    "sql": "SELECT\n  p.payee_name as employee,\n  SUM(\n    CASE\n      WHEN e.lunch_taken = true THEN\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600) - (e.lunch_duration_minutes / 60.0)\n      ELSE\n        (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600)\n    END\n  ) as total_hours,\n  COUNT(DISTINCT e.project_id) as projects_worked,\n  SUM(e.amount) as total_billed\nFROM expenses e\nJOIN payees p ON e.payee_id = p.id\nWHERE p.is_internal = true\n  AND e.category = 'labor_internal'\n  AND e.expense_date >= DATE_TRUNC('month', CURRENT_DATE)\nGROUP BY p.payee_name\nORDER BY total_hours DESC"
  },
  {
    "question": "Show me employees who worked over 8 hour shifts this week",
    "reasoning": "Use gross_hours (total shift duration) not hours (net billable). This is about shift length for compliance, not billable hours.",
    "sql": "SELECT\n  p.payee_name as employee,\n  e.expense_date as work_date,\n  EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600 as gross_hours,\n  CASE\n    WHEN e.lunch_taken = true THEN\n      (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600) - (e.lunch_duration_minutes / 60.0)\n    ELSE\n      (EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600)\n  END as net_hours\nFROM expenses e\nJOIN payees p ON e.payee_id = p.id\nWHERE e.category = 'labor_internal'\n  AND e.expense_date >= CURRENT_DATE - INTERVAL '7 days'\n  AND EXTRACT(EPOCH FROM (e.end_time - e.start_time)) / 3600 > 8\nORDER BY gross_hours DESC"
  },
  {
    "question": "Compare expected vs actual revenue for active projects",
    "reasoning": "contracted_amount is expected, total_invoiced is actual. Calculate the gap.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  contracted_amount as expected_revenue,\n  total_invoiced as actual_revenue,\n  revenue_variance as remaining_to_bill,\n  CASE\n    WHEN contracted_amount > 0\n    THEN ROUND((total_invoiced / contracted_amount * 100)::numeric, 1)\n    ELSE 0\n  END as billing_progress_percent\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status IN ('in_progress', 'approved')\nORDER BY revenue_variance DESC"
  },
  {
    "question": "How do our original estimates compare to actual costs?",
    "reasoning": "Compare original_est_costs to total_expenses. Calculate variance.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  original_est_costs as estimated,\n  total_expenses as actual,\n  (total_expenses - original_est_costs) as variance,\n  CASE\n    WHEN original_est_costs > 0\n    THEN ROUND(((total_expenses - original_est_costs) / original_est_costs * 100)::numeric, 1)\n    ELSE 0\n  END as variance_percent\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status IN ('complete', 'in_progress')\n  AND original_est_costs > 0\nORDER BY variance DESC"
  },
  {
    "question": "What's the status of the Smith project?",
    "reasoning": "Lookup by partial project or client name using ILIKE.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  client_name,\n  status,\n  contracted_amount,\n  total_expenses,\n  current_margin,\n  margin_percentage\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND (project_name ILIKE '%smith%' OR client_name ILIKE '%smith%')"
  },
  {
    "question": "Show me all expenses for project 2024-001",
    "reasoning": "Direct lookup by project number. Get expense details.",
    "sql": "SELECT\n  e.expense_date,\n  e.category,\n  e.amount,\n  e.description,\n  p.payee_name as vendor\nFROM expenses e\nLEFT JOIN payees p ON e.payee_id = p.id\nWHERE e.project_id = (\n  SELECT id FROM projects WHERE project_number = '2024-001'\n)\nORDER BY e.expense_date DESC"
  },
  {
    "question": "What projects did we complete last quarter?",
    "reasoning": "Filter by status='complete' and end_date in previous quarter.",
    "sql": "SELECT\n  project_number,\n  project_name,\n  client_name,\n  end_date,\n  contracted_amount,\n  total_invoiced,\n  actual_margin,\n  margin_percentage\nFROM reporting.project_financials\nWHERE category = 'construction'\n  AND status = 'complete'\n  AND end_date >= DATE_TRUNC('quarter', CURRENT_DATE) - INTERVAL '3 months'\n  AND end_date < DATE_TRUNC('quarter', CURRENT_DATE)\nORDER BY end_date DESC"
  },
  {
    "question": "Show me expenses from yesterday",
    "reasoning": "Simple date filter on expenses table.",
    "sql": "SELECT\n  e.expense_date,\n  proj.project_number,\n  e.category,\n  e.amount,\n  e.description,\n  p.payee_name\nFROM expenses e\nJOIN projects proj ON e.project_id = proj.id\nLEFT JOIN payees p ON e.payee_id = p.id\nWHERE e.expense_date = CURRENT_DATE - INTERVAL '1 day'\nORDER BY e.amount DESC"
  }
],

  // Business benchmarks for contextual insights
  benchmarks: {
  "project_margin": {
    "healthy": "15-30%",
    "warning": ">10%",
    "critical": ">5%"
  },
  "cost_variance": {
    "healthy": "-5-5%",
    "warning": ">10%",
    "critical": ">20%"
  },
  "budget_progress": {
    "healthy": "70-100%",
    "warning": ">50%"
  },
  "labor_cushion_rate": {
    "healthy": "35-50",
    "warning": "n/a"
  },
  "contingency_usage": {
    "healthy": "0-50%",
    "warning": ">75%",
    "critical": ">100%"
  },
  "weekly_hours": {
    "healthy": "35-45",
    "warning": ">50"
  }
},

  // Preferred data sources
  preferredSources: {
    'project financials': 'reporting.project_financials',
    'time entries': "expenses WHERE category = 'labor_internal'",
    'employees': 'payees WHERE is_internal = true',
    'vendors': "payees WHERE payee_type = 'vendor' AND is_internal = false",
    'subcontractors': "payees WHERE payee_type = 'subcontractor' AND is_internal = false",
  },
} as const;

export type KPIContext = typeof KPI_CONTEXT;
